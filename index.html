<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CamOrder ðŸ“¹</title>
  <style>
    :root {
      --bg-0: #0e1217;
      --bg-1: #141a21;
      --panel: #1b222b;
      --panel-hi: #222c37;
      --panel-edge: #2c3744;
      --lane-header-width: 120px;
      --text: #e6ecf3;
      --muted: #98a6b3;
      --accent: #4ad38a;
      --accent-2: #3aa2ff;
      --danger: #ff4d4d;
      --warning: #f2c94c;
      --shadow: rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Trebuchet MS", "Lucida Sans Unicode", "Tahoma", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(58, 162, 255, 0.12), transparent 60%),
        radial-gradient(900px 500px at 85% 15%, rgba(74, 211, 138, 0.12), transparent 65%),
        linear-gradient(160deg, var(--bg-0), var(--bg-1));
      height: 100vh;
      overflow: hidden;
    }

    #app {
      height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      padding: 12px;
      --timeline-height: 260px;
    }

    #topbar {
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: linear-gradient(180deg, var(--panel-hi), var(--panel));
      border: 1px solid var(--panel-edge);
      border-radius: 12px;
      box-shadow: 0 8px 20px var(--shadow);
      min-height: 64px;
    }

    #brand {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #brand h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 1px;
    }

    #brand span {
      font-size: 12px;
      color: var(--muted);
    }

    #statusRow {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    #timeRow {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: flex-end;
    }

    #timeDisplay {
      font-family: "Lucida Console", "Courier New", monospace;
      font-size: 13px;
      background: #0f141a;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #26303b;
    }

    #bpmDisplay {
      font-size: 12px;
      color: var(--muted);
    }

    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.4px;
      background: rgba(152, 166, 179, 0.1);
      color: var(--muted);
      border: 1px solid rgba(152, 166, 179, 0.3);
    }

    .pill.live {
      background: rgba(74, 211, 138, 0.2);
      color: var(--accent);
      border-color: rgba(74, 211, 138, 0.4);
    }

    .pill.recording {
      background: rgba(255, 77, 77, 0.2);
      color: var(--danger);
      border-color: rgba(255, 77, 77, 0.4);
    }

    .pill.warn {
      background: rgba(242, 201, 76, 0.2);
      color: var(--warning);
      border-color: rgba(242, 201, 76, 0.4);
    }

    #content {
      display: grid;
      grid-template-columns: 280px 1fr 320px;
      gap: 10px;
      min-height: 0;
    }

    #app.timeline-enabled #content {
      grid-template-rows: minmax(180px, 1fr) var(--timeline-height);
    }

    #app.timeline-enabled #monitor {
      grid-column: 3;
      grid-row: 1;
      align-self: start;
      display: grid;
      grid-template-rows: auto auto;
      align-content: start;
    }

    #app.timeline-enabled #takes {
      grid-column: 2;
      grid-row: 1;
    }

    #app.timeline-enabled #controls {
      overflow: auto;
    }

    #app.timeline-enabled #controls::-webkit-scrollbar {
      width: 10px;
    }

    #app.timeline-enabled #controls::-webkit-scrollbar-track {
      background: #0b1016;
    }

    #app.timeline-enabled #controls::-webkit-scrollbar-thumb {
      background: #1f2a35;
      border-radius: 8px;
      border: 1px solid #0b1016;
    }

    #app.timeline-enabled #controls::-webkit-scrollbar-thumb:hover {
      background: #2b3847;
    }

    #timelinePanel {
      display: none;
      grid-column: 1 / -1;
      min-height: 220px;
      position: relative;
    }

    #app.timeline-enabled #timelinePanel {
      display: flex;
    }

    #timelineResizeHandle {
      position: absolute;
      top: 0;
      left: 12px;
      right: 12px;
      height: 10px;
      cursor: ns-resize;
      z-index: 6;
    }

    #timelineResizeHandle::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 4px;
      width: 120px;
      height: 2px;
      transform: translateX(-50%);
      border-radius: 999px;
      background: rgba(152, 166, 179, 0.4);
    }

    .panel {
      background: linear-gradient(180deg, #1a222b, #182029);
      border: 1px solid var(--panel-edge);
      border-radius: 12px;
      box-shadow: 0 8px 20px var(--shadow);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .project-block {
      box-shadow: 0 6px 14px var(--shadow);
      width: 100%;
    }

    .panel-header {
      padding: 10px 12px;
      border-bottom: 1px solid #25303b;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .panel-header h3 {
      margin: 0;
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .dawless-controls {
      display: none;
      border-bottom: 1px solid #25303b;
    }

    #app.dawless-enabled .dawless-controls {
      display: grid;
    }

    .toggle-active {
      background: var(--accent);
      border-color: rgba(74, 211, 138, 0.55);
      color: #0c2216;
      font-weight: 700;
    }

    .panel-body {
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      font-size: 11px;
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    button, select, input[type="text"], input[type="number"] {
      background: var(--panel-hi);
      color: var(--text);
      border: 1px solid var(--panel-edge);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 12px;
      outline: none;
    }

    code {
      background: #0f141a;
      border: 1px solid #25303b;
      border-radius: 6px;
      padding: 6px 8px;
      font-family: "Lucida Console", "Courier New", monospace;
      font-size: 11px;
      color: #d9e5ef;
    }

    .help {
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
    }

    .folder-status {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 700;
      background: #331618;
      color: #ff8a8a;
      border: 1px solid #4a1c22;
    }

    .folder-status.ready {
      background: #10351f;
      color: #6ef19b;
      border-color: #1f5a36;
    }

    button {
      cursor: pointer;
      transition: transform 0.12s ease, background 0.2s ease, border-color 0.2s ease;
    }

    button:hover {
      background: #2a3541;
      border-color: #3a4756;
    }

    button:active {
      transform: translateY(1px);
    }

    button.primary {
      background: var(--accent-2);
      border-color: rgba(58, 162, 255, 0.6);
      color: #081b2d;
      font-weight: 700;
    }

    button.danger {
      background: var(--danger);
      border-color: #ff7a7a;
      color: #2b0b0b;
      font-weight: 700;
    }

    button.ghost {
      background: transparent;
      border: 1px dashed var(--panel-edge);
      color: var(--muted);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    #monitorFrame {
      position: relative;
      margin: 10px;
      border-radius: 12px;
      background: #06080b;
      flex: 1 1 auto;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #app.timeline-enabled #monitorFrame {
      margin: 6px 6px 0;
      height: 160px;
      min-height: 0;
    }

    #liveVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: none;
    }

    #monitorPlaceholder {
      color: var(--muted);
      font-size: 13px;
    }

    #takesList {
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: auto;
      flex: 1;
    }

    #app.timeline-enabled #takesList {
      display: none;
    }

    #stageView {
      display: none;
      flex: 1;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      overflow: auto;
    }

    #app.timeline-enabled #stageView {
      display: flex;
    }

    .stage-current {
      font-size: 12px;
      font-weight: 700;
    }

    #stageVideoWrap {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 10px;
      background: #0a0e13;
      border: 1px solid #1f2a35;
      overflow: hidden;
    }

    #stageVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: none;
    }

    #stagePlaceholder {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: var(--muted);
    }

    #stageList {
      display: none;
    }

    .stage-item {
      font-size: 11px;
      color: var(--muted);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #1f2a35;
      background: #0f141a;
    }

    .stage-item.top {
      color: #d9e5ef;
      border-color: #2f4a60;
      background: #16202a;
    }

    .take-item {
      background: #121820;
      border: 1px solid transparent;
      border-radius: 8px;
      padding: 6px;
      display: grid;
      grid-template-columns: 54px 1fr;
      gap: 8px;
      align-items: center;
    }

    .take-title {
      font-size: 12px;
      font-weight: 700;
    }

    .take-meta {
      font-size: 11px;
      color: var(--muted);
    }

    .take-thumb {
      width: 54px;
      height: 36px;
      border-radius: 6px;
      background: #0a0e13;
      border: 1px solid #1f2a35;
      background-size: cover;
      background-position: center;
    }

    .take-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .take-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .take-delete {
      font-size: 11px;
      padding: 4px 6px;
    }

    #timelineBody {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    #timelineViewport {
      position: relative;
      flex: 1;
      overflow: auto;
      background: #0a0e13;
      border-top: 1px solid #1f2a35;
    }

    #timelineViewport::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    #timelineViewport::-webkit-scrollbar-track {
      background: #0b1016;
    }

    #timelineViewport::-webkit-scrollbar-thumb {
      background: #1f2a35;
      border-radius: 8px;
      border: 1px solid #0b1016;
    }

    #timelineViewport::-webkit-scrollbar-thumb:hover {
      background: #2b3847;
    }

    #monitorProjectSlot {
      padding: 6px 10px 10px;
      display: grid;
      gap: 10px;
      flex: 0 0 auto;
    }

    #monitor {
      gap: 8px;
    }

    #timelineCanvas {
      position: relative;
      min-height: 100%;
      background-color: #0b1016;
    }

    #timelineRuler {
      position: relative;
      height: 24px;
      border-bottom: 1px solid #1f2a35;
      background: rgba(12, 16, 22, 0.9);
      z-index: 2;
      box-sizing: border-box;
    }

    .ruler-label {
      position: absolute;
      top: 4px;
      font-size: 10px;
      color: var(--muted);
      transform: translateX(0);
      white-space: nowrap;
    }

    #timelineLanes {
      position: relative;
    }

    .timeline-lane {
      position: relative;
      height: 54px;
      border-bottom: 1px solid #1b2430;
    }

    .lane-header {
      position: sticky;
      left: 0;
      top: 0;
      height: 100%;
      width: var(--lane-header-width);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      padding: 0 10px;
      background: #121820;
      border-right: 1px solid #1f2a35;
      z-index: 4;
    }

    .lane-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .lane-arm {
      width: 26px;
      height: 24px;
      padding: 0;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 700;
    }

    .lane-arm.armed {
      background: var(--danger);
      border-color: #ff7a7a;
      color: #2b0b0b;
    }

    .timeline-clip {
      position: absolute;
      top: 7px;
      height: 40px;
      background: #2a3a4b;
      border: 1px solid #3e566f;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      color: #d9e5ef;
      cursor: grab;
      box-sizing: border-box;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .timeline-clip.locked {
      cursor: default;
    }

    .timeline-clip.selected {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 1px rgba(46, 196, 182, 0.35);
    }

    .clip-handle {
      position: absolute;
      top: 0;
      width: 6px;
      height: 100%;
      background: rgba(79, 104, 131, 0.9);
      cursor: ew-resize;
    }

    .clip-handle.left {
      left: 0;
      border-top-left-radius: 6px;
      border-bottom-left-radius: 6px;
    }

    .clip-handle.right {
      right: 0;
      border-top-right-radius: 6px;
      border-bottom-right-radius: 6px;
    }

    #timelinePlayhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(255, 77, 77, 0.8);
      z-index: 5;
      pointer-events: none;
    }

    #experimentalBar {
      margin-top: 10px;
      display: flex;
      justify-content: center;
    }

    .export-status {
      min-width: 70px;
      font-size: 11px;
      font-weight: 700;
      color: var(--accent);
      opacity: 0;
    }

    .export-status.show {
      animation: exportFade 2.6s ease forwards;
    }

    .export-history {
      font-size: 11px;
      color: var(--muted);
    }

    @keyframes exportFade {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }

    @media (max-width: 1100px) {
      #content {
        grid-template-columns: 1fr;
      }

      #topbar {
        grid-template-columns: 1fr;
        justify-items: start;
      }

      #timeRow,
      #statusRow {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header id="topbar">
      <div id="brand">
        <h1>CamOrder ðŸ“¹</h1>
        <span>MIDI clock synced video capture for DAWs</span>
      </div>
      <div id="statusRow">
        <span id="midiStatus" class="pill">MIDI Off</span>
        <span id="recordStatus" class="pill">Idle</span>
        <span id="cameraStatus" class="pill">Camera Off</span>
        <span id="folderPill" class="pill">Folder Missing</span>
      </div>
      <div id="timeRow">
        <span id="timeDisplay">00:00:00:00</span>
        <span id="bpmDisplay">120.0 BPM</span>
      </div>
    </header>

    <section id="content">
      <aside id="controls" class="panel">
        <div class="panel-header"><h3>Sync</h3></div>
        <div class="panel-body">
          <div class="field">
            <label>MIDI Input (Clock)</label>
            <select id="midiInputSelect"></select>
          </div>
          <div class="row">
            <button id="midiConnectBtn" class="ghost">Enable MIDI</button>
            <button id="armBtn" class="danger">Arm Recorder</button>
          </div>
          <div class="row">
            <label>FPS
              <select id="fpsSelect">
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="30" selected>30</option>
                <option value="60">60</option>
              </select>
            </label>
          </div>
        </div>

        <div class="panel-header"><h3>Camera</h3></div>
        <div class="panel-body">
          <div class="field">
            <label>Source</label>
            <select id="cameraSelect"></select>
          </div>
          <div class="field">
            <label>Resolution</label>
            <select id="resolutionSelect"></select>
          </div>
          <div class="row">
            <button id="enableCameraBtn" class="ghost">Enable Camera</button>
            <button id="refreshDevices" class="ghost">Refresh</button>
          </div>
        </div>

        <div id="projectSlot">
          <div id="projectBlock" class="panel project-block">
            <div class="panel-header"><h3>Project</h3></div>
            <div class="panel-body">
              <div class="row">
                <button id="chooseFolderBtn" class="ghost">Choose Project Folder</button>
                <span id="folderStatus" class="folder-status">X</span>
              </div>
              <div class="row">
                <button id="exportPackageBtn" class="primary">Export Resolve Package</button>
                <span id="exportStatusBadge" class="export-status"></span>
              </div>
              <div id="exportHistory" class="export-history"></div>
              <div class="field">
                <label>Convert Command</label>
                <div class="row">
                  <code id="convertCmdInline">sh convert-to-mov.sh</code>
                  <button id="copyConvertBtn" class="ghost">Copy</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </aside>

      <section id="monitor" class="panel">
        <div class="panel-header"><h3>Live Preview</h3></div>
        <div id="monitorFrame">
          <video id="liveVideo" muted playsinline autoplay></video>
          <div id="monitorPlaceholder">Enable camera to preview the feed.</div>
        </div>
        <div id="monitorProjectSlot"></div>
      </section>

      <aside id="takes" class="panel">
        <div class="panel-header">
          <h3 id="takesHeader">Takes</h3>
        </div>
        <div id="takesList"></div>
        <div id="stageView">
          <div id="stageVideoWrap">
            <video id="stageVideo" muted playsinline></video>
            <div id="stagePlaceholder">No clip at playhead.</div>
          </div>
          <div id="stageCurrent" class="stage-current">Stage: None</div>
          <div id="stageList"></div>
        </div>
      </aside>

      <section id="timelinePanel" class="panel">
        <div id="timelineResizeHandle" aria-hidden="true"></div>
        <div class="panel-header">
          <h3>Video Timeline</h3>
          <div class="row">
            <button id="toggleDawlessBtn" class="ghost">DAW-less Mode</button>
            <button id="addLaneBtn" class="ghost">Add Lane</button>
            <button id="deletePlacementBtn" class="ghost">Delete Clip</button>
          </div>
        </div>
        <div id="dawlessControls" class="panel-body dawless-controls">
          <div class="row">
            <button id="dawlessPlayBtn" class="ghost">Play</button>
            <button id="metronomeBtn" class="ghost">Metronome</button>
            <label>Tempo
              <input id="tempoInput" type="number" min="40" max="240" step="0.1" value="120" />
            </label>
          </div>
          <div class="row">
            <label>Audio Input
              <select id="audioInputSelect"></select>
            </label>
            <button id="refreshAudioBtn" class="ghost">Refresh Audio</button>
          </div>
        </div>
        <div id="timelineBody">
          <div id="timelineViewport">
            <div id="timelineCanvas">
              <div id="timelineRuler"></div>
              <div id="timelineLanes"></div>
              <div id="timelinePlayhead"></div>
            </div>
          </div>
        </div>
      </section>
    </section>

    <div id="experimentalBar">
      <button id="toggleTimelineBtn" class="ghost">Video Timeline</button>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      const pad = (num, size = 2) => String(num).padStart(size, '0');

      function secondsToSMPTE(seconds, fps) {
        const safe = Math.max(0, seconds || 0);
        const totalFrames = Math.floor(safe * fps + 1e-6);
        const frames = totalFrames % fps;
        const totalSeconds = Math.floor(totalFrames / fps);
        const secs = totalSeconds % 60;
        const mins = Math.floor(totalSeconds / 60) % 60;
        const hours = Math.floor(totalSeconds / 3600);
        return `${pad(hours)}:${pad(mins)}:${pad(secs)}:${pad(frames)}`;
      }

      function secondsToFcpDuration(seconds, fps) {
        const frames = Math.max(0, Math.round(seconds * fps));
        if (frames === 0) return '0s';
        return `${frames}/${fps}s`;
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function snapSeconds(seconds, fps) {
        const frame = 1 / fps;
        return Math.round(seconds / frame) * frame;
      }

      const state = {
        settings: {
          fps: 30,
        },
        export: {
          mediaBasePath: '',
          statusMessage: '',
        },
        dawless: {
          enabled: false,
          tempoBpm: 120,
          playing: false,
          metronomeOn: false,
          lastBeatIndex: -1,
          lastTickMs: 0,
          rafId: 0,
          audioInputId: '',
          audioStream: null,
          audioCtx: null,
        },
        midi: {
          access: null,
          input: null,
          connected: false,
          clock: {
            lastTick: 0,
            bpm: 120,
            playing: false,
            songPositionSeconds: 0,
          },
        },
        camera: {
          stream: null,
          source: null,
          status: 'off',
        },
        recording: {
          active: false,
          pending: false,
          clipId: null,
          startPlayhead: 0,
          recorder: null,
          chunks: [],
        },
        timeline: {
          enabled: false,
          lanes: 3,
          selectedLane: 0,
          pxPerBeat: 84,
          subdivisions: 4,
          beatsPerBar: 4,
          selectionId: null,
          drag: null,
          lastGridBpm: 0,
        },
        stage: {
          currentPlacementId: '',
          updateToken: 0,
          lastUrl: '',
        },
        clips: [],
        placements: [],
        mediaCache: new Map(),
        mediaHandles: new Map(),
        playheadSeconds: 0,
        armed: true,
        projectHandle: null,
        dirty: false,
      };

      const dom = {};

      function cacheDom() {
        dom.midiStatus = document.getElementById('midiStatus');
        dom.recordStatus = document.getElementById('recordStatus');
        dom.cameraStatus = document.getElementById('cameraStatus');
        dom.timeDisplay = document.getElementById('timeDisplay');
        dom.bpmDisplay = document.getElementById('bpmDisplay');
        dom.midiInputSelect = document.getElementById('midiInputSelect');
        dom.midiConnectBtn = document.getElementById('midiConnectBtn');
        dom.armBtn = document.getElementById('armBtn');
        dom.fpsSelect = document.getElementById('fpsSelect');
        dom.folderPill = document.getElementById('folderPill');
        dom.cameraSelect = document.getElementById('cameraSelect');
        dom.resolutionSelect = document.getElementById('resolutionSelect');
        dom.enableCameraBtn = document.getElementById('enableCameraBtn');
        dom.refreshDevices = document.getElementById('refreshDevices');
        dom.chooseFolderBtn = document.getElementById('chooseFolderBtn');
        dom.exportPackageBtn = document.getElementById('exportPackageBtn');
        dom.exportStatusBadge = document.getElementById('exportStatusBadge');
        dom.exportHistory = document.getElementById('exportHistory');
        dom.convertCmdInline = document.getElementById('convertCmdInline');
        dom.copyConvertBtn = document.getElementById('copyConvertBtn');
        dom.folderStatus = document.getElementById('folderStatus');
        dom.liveVideo = document.getElementById('liveVideo');
        dom.monitorPlaceholder = document.getElementById('monitorPlaceholder');
        dom.projectBlock = document.getElementById('projectBlock');
        dom.projectSlot = document.getElementById('projectSlot');
        dom.monitorProjectSlot = document.getElementById('monitorProjectSlot');
        dom.content = document.getElementById('content');
        dom.takesList = document.getElementById('takesList');
        dom.takesHeader = document.getElementById('takesHeader');
        dom.stageView = document.getElementById('stageView');
        dom.stageCurrent = document.getElementById('stageCurrent');
        dom.stageList = document.getElementById('stageList');
        dom.stageVideo = document.getElementById('stageVideo');
        dom.stagePlaceholder = document.getElementById('stagePlaceholder');
        dom.timelinePanel = document.getElementById('timelinePanel');
        dom.timelineViewport = document.getElementById('timelineViewport');
        dom.timelineCanvas = document.getElementById('timelineCanvas');
        dom.timelineRuler = document.getElementById('timelineRuler');
        dom.timelineLanes = document.getElementById('timelineLanes');
        dom.timelinePlayhead = document.getElementById('timelinePlayhead');
        dom.timelineResizeHandle = document.getElementById('timelineResizeHandle');
        dom.laneSelect = document.getElementById('laneSelect');
        dom.toggleDawlessBtn = document.getElementById('toggleDawlessBtn');
        dom.dawlessPlayBtn = document.getElementById('dawlessPlayBtn');
        dom.metronomeBtn = document.getElementById('metronomeBtn');
        dom.tempoInput = document.getElementById('tempoInput');
        dom.audioInputSelect = document.getElementById('audioInputSelect');
        dom.refreshAudioBtn = document.getElementById('refreshAudioBtn');
        dom.addLaneBtn = document.getElementById('addLaneBtn');
        dom.deletePlacementBtn = document.getElementById('deletePlacementBtn');
        dom.toggleTimelineBtn = document.getElementById('toggleTimelineBtn');
      }

      function markDirty() {
        state.dirty = true;
      }

      function makeId(prefix) {
        return `${prefix}-${Math.random().toString(36).slice(2, 9)}`;
      }

      function formatClockTime(date = new Date()) {
        const time = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        return time.replace('AM', 'am').replace('PM', 'pm');
      }

      function isTransportPlaying() {
        return state.dawless.enabled ? state.dawless.playing : state.midi.clock.playing;
      }

      function setPlayhead(seconds) {
        const snapped = Math.max(0, snapSeconds(seconds, state.settings.fps));
        state.playheadSeconds = snapped;
        dom.timeDisplay.textContent = secondsToSMPTE(snapped, state.settings.fps);
        updateTimelinePlayhead();
        renderStageView();
      }

      function setMidiStatus(status, label = '') {
        let text = label || 'MIDI Off';
        let cls = 'pill';
        if (status === 'ready') {
          text = label || 'MIDI Ready';
          cls = 'pill live';
        } else if (status === 'connected') {
          text = label || 'MIDI Connected';
          cls = 'pill live';
        } else if (status === 'warn') {
          text = label || 'MIDI Warning';
          cls = 'pill warn';
        }
        dom.midiStatus.textContent = text;
        dom.midiStatus.className = cls;
      }

      function setRecordStatus(status) {
        if (status === 'recording') {
          dom.recordStatus.textContent = 'Recording';
          dom.recordStatus.className = 'pill recording';
        } else if (status === 'armed') {
          dom.recordStatus.textContent = 'Armed';
          dom.recordStatus.className = 'pill live';
        } else {
          dom.recordStatus.textContent = 'Idle';
          dom.recordStatus.className = 'pill';
        }
      }

      function setCameraStatus(status) {
        state.camera.status = status;
        if (status === 'ready') {
          dom.cameraStatus.textContent = 'Camera Ready';
          dom.cameraStatus.className = 'pill live';
        } else if (status === 'blocked') {
          dom.cameraStatus.textContent = 'Camera Blocked';
          dom.cameraStatus.className = 'pill warn';
        } else if (status === 'busy') {
          dom.cameraStatus.textContent = 'Camera Busy';
          dom.cameraStatus.className = 'pill warn';
        } else if (status === 'live') {
          dom.cameraStatus.textContent = 'Camera Live';
          dom.cameraStatus.className = 'pill recording';
        } else {
          dom.cameraStatus.textContent = 'Camera Off';
          dom.cameraStatus.className = 'pill';
        }
      }

      function updateExportNotes() {
        if (!dom.exportNotes) return;
        dom.exportNotes.textContent = state.export.statusMessage || '';
      }

      function setExportStatus(message) {
        state.export.statusMessage = message || '';
        updateExportNotes();
      }

      function setExportBadge(action) {
        if (!dom.exportStatusBadge) return;
        const text = action === 'updated' ? 'Updated' : 'Exported';
        dom.exportStatusBadge.textContent = text;
        dom.exportStatusBadge.classList.remove('show');
        void dom.exportStatusBadge.offsetWidth;
        dom.exportStatusBadge.classList.add('show');
        if (dom.exportHistory) {
          const stamp = formatClockTime(new Date());
          const historyText = action === 'updated' ? `Updated ${stamp}` : `Exported ${stamp}`;
          dom.exportHistory.textContent = historyText;
        }
      }

      function updateFolderStatus() {
        if (!dom.folderStatus) return;
        if (state.projectHandle) {
          dom.folderStatus.textContent = 'OK';
          dom.folderStatus.classList.add('ready');
          if (dom.folderPill) {
            dom.folderPill.textContent = 'Folder Ready';
            dom.folderPill.className = 'pill live';
          }
        } else {
          dom.folderStatus.textContent = 'X';
          dom.folderStatus.classList.remove('ready');
          if (dom.folderPill) {
            dom.folderPill.textContent = 'Folder Missing';
            dom.folderPill.className = 'pill warn';
          }
        }
      }

      function moveProjectBlock() {
        if (!dom.projectBlock || !dom.projectSlot || !dom.monitorProjectSlot) return;
        if (dom.projectBlock.parentElement !== dom.projectSlot) {
          dom.projectSlot.appendChild(dom.projectBlock);
        }
      }

      function getActivePlacementsAtPlayhead() {
        return state.placements.filter((placement) => {
          const start = placement.timelineStartSeconds;
          const end = placement.timelineStartSeconds + placement.durationSeconds;
          return state.playheadSeconds >= start && state.playheadSeconds <= end;
        });
      }

      function renderStageView() {
        if (!dom.stageCurrent) return;
        if (!state.timeline.enabled) return;
        const active = getActivePlacementsAtPlayhead();
        const enriched = active.map((placement) => {
          const clip = getClipById(placement.clipId);
          return {
            placement,
            clip,
            lane: typeof placement.lane === 'number' ? placement.lane : 0,
          };
        });
        enriched.sort((a, b) => a.lane - b.lane);
        const top = enriched.length ? enriched[enriched.length - 1] : null;
        dom.stageCurrent.textContent = top && top.clip
          ? `Stage: ${top.clip.name}`
          : 'Stage: None';
        if (dom.stageList) {
          dom.stageList.innerHTML = '';
        }
        if (!top || !top.clip) {
          if (dom.stageList) {
            const empty = document.createElement('div');
            empty.className = 'stage-item';
            empty.textContent = 'No clips at playhead.';
            dom.stageList.appendChild(empty);
          }
          updateStageVideo(null);
          return;
        }
        if (dom.stageList) {
          const row = document.createElement('div');
          row.className = 'stage-item top';
          row.textContent = `Lane ${top.lane + 1}: ${top.clip.name}`;
          dom.stageList.appendChild(row);
        }
        updateStageVideo(top);
      }

      async function ensureClipMedia(clip) {
        if (!clip) return '';
        const cached = state.mediaCache.get(clip.id);
        if (cached && cached.url) return cached.url;
        if (!state.projectHandle || !clip.filename) return '';
        let handle = state.mediaHandles.get(clip.filename);
        if (!handle) {
          const base = clip.filename.replace(/\.[^/.]+$/, '');
          const mov = `${base}.mov`;
          const webm = `${base}.webm`;
          handle = state.mediaHandles.get(mov) || state.mediaHandles.get(webm) || null;
          if (handle) clip.filename = handle.name || clip.filename;
        }
        if (!handle) {
          try {
            const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: false });
            handle = await mediaDir.getFileHandle(clip.filename);
            state.mediaHandles.set(clip.filename, handle);
          } catch (error) {
            return '';
          }
        }
        const file = await handle.getFile();
        const url = URL.createObjectURL(file);
        state.mediaCache.set(clip.id, { blob: file, url, filename: clip.filename });
        return url;
      }

      async function updateStageVideo(topEntry) {
        if (!dom.stageVideo || !dom.stagePlaceholder) return;
        if (!topEntry || !topEntry.clip) {
          dom.stageVideo.removeAttribute('src');
          dom.stageVideo.load();
          dom.stageVideo.style.display = 'none';
          dom.stagePlaceholder.style.display = 'flex';
          state.stage.currentPlacementId = '';
          state.stage.lastUrl = '';
          return;
        }
        const placementId = topEntry.placement.id;
        const seekTime = Math.max(
          0,
          (state.playheadSeconds - topEntry.placement.timelineStartSeconds) + topEntry.placement.clipInSeconds
        );
        state.stage.updateToken += 1;
        const token = state.stage.updateToken;
        const url = await ensureClipMedia(topEntry.clip);
        if (token !== state.stage.updateToken) return;
        if (!url) return;
        const clipChanged = state.stage.currentPlacementId !== placementId || state.stage.lastUrl !== url;
        if (clipChanged || dom.stageVideo.src !== url) {
          dom.stageVideo.src = url;
          dom.stageVideo.load();
          state.stage.lastUrl = url;
        }
        dom.stagePlaceholder.style.display = 'none';
        dom.stageVideo.style.display = 'block';
        const applySeek = () => {
          const drift = Math.abs((dom.stageVideo.currentTime || 0) - seekTime);
          if (!state.midi.clock.playing || clipChanged || drift > 0.2) {
            try {
              dom.stageVideo.currentTime = seekTime;
            } catch (error) {
              // Ignore seek errors for unloaded media.
            }
          }
          if (isTransportPlaying()) {
            dom.stageVideo.play().catch(() => {});
          } else {
            dom.stageVideo.pause();
          }
        };
        if (dom.stageVideo.readyState >= 1) {
          applySeek();
        } else {
          dom.stageVideo.onloadedmetadata = applySeek;
        }
        state.stage.currentPlacementId = placementId;
      }

      function getBpm() {
        if (state.dawless.enabled) {
          return Math.max(20, state.dawless.tempoBpm || 120);
        }
        return Math.max(20, state.midi.clock.bpm || 120);
      }

      function getSecondsPerBeat() {
        return 60 / getBpm();
      }

      function snapToBeatGrid(seconds) {
        const grid = getSecondsPerBeat() / state.timeline.subdivisions;
        if (!grid) return seconds;
        const snapped = Math.round(seconds / grid) * grid;
        return Math.max(0, Number(snapped.toFixed(6)));
      }

      function snapToBeatGridCeil(seconds) {
        const grid = getSecondsPerBeat() / state.timeline.subdivisions;
        if (!grid) return seconds;
        const snapped = Math.ceil(seconds / grid) * grid;
        return Math.max(0, Number(snapped.toFixed(6)));
      }

      function getLaneHeaderWidth() {
        return 120;
      }

      async function refreshAudioInputs(allowPrompt = false) {
        if (!dom.audioInputSelect) return;
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          dom.audioInputSelect.innerHTML = '<option value="">Audio unavailable</option>';
          return;
        }
        try {
          let devices = await navigator.mediaDevices.enumerateDevices();
          let inputs = devices.filter((device) => device.kind === 'audioinput');
          const hasLabels = inputs.some((input) => input.label);
          if (!hasLabels && allowPrompt) {
            try {
              const probe = await navigator.mediaDevices.getUserMedia({ audio: true });
              probe.getTracks().forEach((track) => track.stop());
              devices = await navigator.mediaDevices.enumerateDevices();
              inputs = devices.filter((device) => device.kind === 'audioinput');
            } catch (error) {
              // Ignore permission denial; we'll fall back to generic names.
            }
          }
          dom.audioInputSelect.innerHTML = '';
          if (!inputs.length) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No audio inputs';
            dom.audioInputSelect.appendChild(opt);
            return;
          }
          inputs.forEach((input, index) => {
            const opt = document.createElement('option');
            opt.value = input.deviceId;
            opt.textContent = input.label || `Audio Input ${index + 1}`;
            dom.audioInputSelect.appendChild(opt);
          });
          const preferred = state.dawless.audioInputId;
          if (preferred && inputs.some((input) => input.deviceId === preferred)) {
            dom.audioInputSelect.value = preferred;
          } else {
            dom.audioInputSelect.value = inputs[0].deviceId;
            state.dawless.audioInputId = inputs[0].deviceId;
          }
        } catch (error) {
          dom.audioInputSelect.innerHTML = '<option value="">Audio list blocked</option>';
        }
      }

      async function getAudioStream() {
        if (!state.dawless.enabled) return null;
        const desiredId = state.dawless.audioInputId;
        if (state.dawless.audioStream) {
          const track = state.dawless.audioStream.getAudioTracks()[0];
          const currentId = track ? track.getSettings().deviceId : '';
          if (!desiredId || currentId === desiredId) {
            return state.dawless.audioStream;
          }
          state.dawless.audioStream.getTracks().forEach((t) => t.stop());
        }
        try {
          const constraints = desiredId
            ? { audio: { deviceId: { exact: desiredId } } }
            : { audio: true };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          state.dawless.audioStream = stream;
          return stream;
        } catch (error) {
          alert(`Unable to access audio input: ${error.message}`);
          return null;
        }
      }

      function stopAudioStream() {
        if (state.dawless.audioStream) {
          state.dawless.audioStream.getTracks().forEach((track) => track.stop());
          state.dawless.audioStream = null;
        }
      }

      async function getRecordingStream() {
        const videoStream = await getCameraStream();
        if (!videoStream) return null;
        if (!state.dawless.enabled) return videoStream;
        const audioStream = await getAudioStream();
        const tracks = [...videoStream.getVideoTracks()];
        if (audioStream) {
          tracks.push(...audioStream.getAudioTracks());
        }
        return new MediaStream(tracks);
      }

      function playMetronomeClick(strong) {
        if (!state.dawless.metronomeOn) return;
        if (!state.dawless.audioCtx) {
          state.dawless.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const ctx = state.dawless.audioCtx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.value = strong ? 880 : 660;
        gain.gain.value = 0.0001;
        osc.connect(gain);
        gain.connect(ctx.destination);
        const now = ctx.currentTime;
        gain.gain.exponentialRampToValueAtTime(strong ? 0.2 : 0.12, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
        osc.start(now);
        osc.stop(now + 0.09);
      }

      function dawlessTick(now) {
        if (!state.dawless.playing) return;
        if (!state.dawless.lastTickMs) state.dawless.lastTickMs = now;
        const delta = Math.max(0, (now - state.dawless.lastTickMs) / 1000);
        state.dawless.lastTickMs = now;
        const next = state.playheadSeconds + delta;
        setPlayhead(next);
        if (state.recording.active) {
          updateRecordingDuration();
        }
        if (state.dawless.metronomeOn) {
          const beatIndex = Math.floor(state.playheadSeconds / getSecondsPerBeat());
          if (beatIndex !== state.dawless.lastBeatIndex) {
            state.dawless.lastBeatIndex = beatIndex;
            const strong = beatIndex % state.timeline.beatsPerBar === 0;
            playMetronomeClick(strong);
          }
        }
        if (canAutoRecord()) {
          if (!state.recording.active && !state.recording.pending) {
            startRecording();
          }
        }
        state.dawless.rafId = requestAnimationFrame(dawlessTick);
      }

      function startDawlessTransport() {
        if (state.dawless.playing) return;
        state.dawless.playing = true;
        state.dawless.lastTickMs = 0;
        state.dawless.lastBeatIndex = -1;
        dom.dawlessPlayBtn?.classList.add('toggle-active');
        dom.dawlessPlayBtn.textContent = 'Stop';
        state.dawless.rafId = requestAnimationFrame(dawlessTick);
      }

      function stopDawlessTransport() {
        state.dawless.playing = false;
        state.dawless.lastTickMs = 0;
        state.dawless.lastBeatIndex = -1;
        if (state.dawless.rafId) {
          cancelAnimationFrame(state.dawless.rafId);
          state.dawless.rafId = 0;
        }
        dom.dawlessPlayBtn?.classList.remove('toggle-active');
        if (dom.dawlessPlayBtn) dom.dawlessPlayBtn.textContent = 'Play';
        if (state.recording.active) stopRecording();
      }

      function setDawlessEnabled(enabled) {
        state.dawless.enabled = enabled;
        document.getElementById('app').classList.toggle('dawless-enabled', enabled);
        if (dom.toggleDawlessBtn) {
          dom.toggleDawlessBtn.classList.toggle('toggle-active', enabled);
          dom.toggleDawlessBtn.textContent = enabled ? 'DAW-less: On' : 'DAW-less Mode';
        }
        if (dom.metronomeBtn) {
          dom.metronomeBtn.classList.toggle('toggle-active', state.dawless.metronomeOn);
        }
        if (dom.dawlessPlayBtn) dom.dawlessPlayBtn.disabled = !enabled;
        if (dom.metronomeBtn) dom.metronomeBtn.disabled = !enabled;
        if (dom.tempoInput) dom.tempoInput.disabled = !enabled;
        if (dom.audioInputSelect) dom.audioInputSelect.disabled = !enabled;
        if (dom.refreshAudioBtn) dom.refreshAudioBtn.disabled = !enabled;
        if (dom.tempoInput) dom.tempoInput.value = String(state.dawless.tempoBpm);
        if (dom.stageVideo) dom.stageVideo.muted = !enabled;
        if (!enabled) {
          stopDawlessTransport();
          stopAudioStream();
        } else {
          refreshAudioInputs(true);
        }
        updateBpmDisplay();
        renderTimeline();
      }

      function clampTimelineHeight(value) {
        const contentHeight = dom.content ? dom.content.clientHeight : 0;
        const minHeight = 180;
        const maxHeight = Math.max(minHeight, contentHeight - 180);
        return clamp(value, minHeight, maxHeight);
      }

      function setTimelineHeight(px) {
        const clamped = clampTimelineHeight(px);
        document.getElementById('app').style.setProperty('--timeline-height', `${clamped}px`);
      }
      function timeToPx(seconds) {
        return (seconds / getSecondsPerBeat()) * state.timeline.pxPerBeat;
      }

      function pxToTime(pixels) {
        return (pixels / state.timeline.pxPerBeat) * getSecondsPerBeat();
      }

      function updateLaneSelect() {
        if (state.timeline.selectedLane >= state.timeline.lanes) {
          state.timeline.selectedLane = Math.max(0, state.timeline.lanes - 1);
        }
        if (!dom.laneSelect) return;
        dom.laneSelect.innerHTML = '';
        for (let i = 0; i < state.timeline.lanes; i += 1) {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `Lane ${i + 1}`;
          dom.laneSelect.appendChild(opt);
        }
        dom.laneSelect.value = String(state.timeline.selectedLane);
      }

      function getTimelineSpanSeconds() {
        const baseline = Math.max(getTimelineDurationSeconds(), state.playheadSeconds);
        const beatsAhead = state.timeline.beatsPerBar * 4;
        return Math.max(baseline, state.playheadSeconds + getSecondsPerBeat() * beatsAhead);
      }

      function updateTimelineGrid(widthPx) {
        if (!dom.timelineCanvas) return;
        const beatPx = state.timeline.pxPerBeat;
        const subPx = beatPx / state.timeline.subdivisions;
        const barPx = beatPx * state.timeline.beatsPerBar;
        const headerWidth = getLaneHeaderWidth();
        dom.timelineCanvas.style.backgroundImage = [
          'linear-gradient(to right, rgba(42, 53, 65, 0.55) 1px, transparent 1px)',
          'linear-gradient(to right, rgba(28, 37, 47, 0.5) 1px, transparent 1px)',
          'linear-gradient(to right, rgba(22, 28, 36, 0.35) 1px, transparent 1px)',
        ].join(', ');
        dom.timelineCanvas.style.backgroundSize = `${barPx}px 100%, ${beatPx}px 100%, ${subPx}px 100%`;
        dom.timelineCanvas.style.backgroundPosition = `${headerWidth}px 0, ${headerWidth}px 0, ${headerWidth}px 0`;
        dom.timelineCanvas.style.width = `${Math.max(widthPx + headerWidth, dom.timelineViewport.clientWidth)}px`;
      }

      function renderTimelineRuler(spanSeconds) {
        if (!dom.timelineRuler) return;
        dom.timelineRuler.innerHTML = '';
        const beats = Math.ceil(spanSeconds / getSecondsPerBeat());
        const totalBars = Math.max(1, Math.ceil(beats / state.timeline.beatsPerBar));
        const headerWidth = getLaneHeaderWidth();
        for (let bar = 0; bar <= totalBars; bar += 1) {
          const beat = bar * state.timeline.beatsPerBar;
          const seconds = beat * getSecondsPerBeat();
          const left = timeToPx(seconds) + headerWidth;
          const label = document.createElement('div');
          label.className = 'ruler-label';
          label.style.left = `${left}px`;
          label.textContent = `${bar + 1}`;
          dom.timelineRuler.appendChild(label);
        }
      }

      function renderTimeline() {
        if (!state.timeline.enabled) return;
        if (!dom.timelineCanvas || !dom.timelineLanes) return;
        updateLaneSelect();
        const spanSeconds = getTimelineSpanSeconds();
        const widthPx = timeToPx(spanSeconds) + 200;
        updateTimelineGrid(widthPx);
        dom.timelineRuler.style.width = dom.timelineCanvas.style.width;
        dom.timelineLanes.style.width = dom.timelineCanvas.style.width;
        renderTimelineRuler(spanSeconds);

        dom.timelineLanes.innerHTML = '';
        for (let lane = 0; lane < state.timeline.lanes; lane += 1) {
          const row = document.createElement('div');
          row.className = 'timeline-lane';
          row.dataset.lane = String(lane);
          const header = document.createElement('div');
          header.className = 'lane-header';
          const label = document.createElement('div');
          label.className = 'lane-label';
          label.textContent = `Lane ${lane + 1}`;
          const armBtn = document.createElement('button');
          armBtn.className = 'lane-arm';
          armBtn.textContent = 'R';
          if (state.timeline.selectedLane === lane) {
            armBtn.classList.add('armed');
          }
          armBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            state.timeline.selectedLane = lane;
            renderTimeline();
          });
          header.appendChild(label);
          header.appendChild(armBtn);
          row.appendChild(header);
          dom.timelineLanes.appendChild(row);
        }

        const placements = state.placements.filter((placement) => placement.durationSeconds > 0.01);
        placements.forEach((placement) => {
          if (typeof placement.lane !== 'number') placement.lane = 0;
          const laneIndex = Math.max(0, Math.min(state.timeline.lanes - 1, placement.lane));
          const row = dom.timelineLanes.querySelector(`[data-lane="${laneIndex}"]`);
          if (!row) return;
          const clip = getClipById(placement.clipId);
          const clipEl = document.createElement('div');
          clipEl.className = 'timeline-clip';
          clipEl.dataset.placementId = placement.id;
          const clipStart = placement.timelineStartSeconds;
          const duration = Math.max(0.01, placement.durationSeconds);
          clipEl.style.left = `${timeToPx(clipStart) + getLaneHeaderWidth()}px`;
          clipEl.style.width = `${Math.max(12, timeToPx(duration))}px`;
          clipEl.textContent = clip ? clip.name : placement.clipId;
          if (clip && clip.source === 'recorded') {
            clipEl.classList.add('locked');
          }
          if (state.timeline.selectionId === placement.id) {
            clipEl.classList.add('selected');
          }
          const leftHandle = document.createElement('div');
          leftHandle.className = 'clip-handle left';
          const rightHandle = document.createElement('div');
          rightHandle.className = 'clip-handle right';
          clipEl.appendChild(leftHandle);
          clipEl.appendChild(rightHandle);
          row.appendChild(clipEl);
        });

        updateTimelinePlayhead();
        renderStageView();
      }

      function updateTimelinePlayhead() {
        if (!state.timeline.enabled || !dom.timelinePlayhead) return;
        const left = timeToPx(state.playheadSeconds) + getLaneHeaderWidth();
        dom.timelinePlayhead.style.left = `${left}px`;
      }

      function updateTimelineRecordingClip() {
        if (!state.timeline.enabled || !state.recording.active) return;
        const placement = state.placements.find((item) => item.clipId === state.recording.clipId);
        if (!placement) return;
        const el = dom.timelineCanvas
          ? dom.timelineCanvas.querySelector(`[data-placement-id="${placement.id}"]`)
          : null;
        if (!el) {
          renderTimeline();
          return;
        }
        el.style.left = `${timeToPx(placement.timelineStartSeconds) + getLaneHeaderWidth()}px`;
        el.style.width = `${Math.max(12, timeToPx(placement.durationSeconds))}px`;
      }

      function selectPlacement(placementId) {
        state.timeline.selectionId = placementId;
        renderTimeline();
      }

      function deleteSelectedPlacement() {
        const selection = state.timeline.selectionId;
        if (!selection) return;
        const target = getPlacementById(selection);
        state.placements = state.placements.filter((placement) => placement.id !== selection);
        state.timeline.selectionId = null;
        if (target) {
          maybeDeleteClipMedia(target.clipId);
        }
        markDirty();
        renderTimeline();
        updateProjectFcpxml();
      }

      function handleTimelineMouseDown(event) {
        if (!state.timeline.enabled) return;
        if (!dom.timelineCanvas || !dom.timelineViewport) return;
        const clipEl = event.target.closest('.timeline-clip');
        if (clipEl) {
          const placementId = clipEl.dataset.placementId;
          const placement = getPlacementById(placementId);
          if (!placement) return;
          const clip = getClipById(placement.clipId);
          selectPlacement(placementId);
          const rect = clipEl.getBoundingClientRect();
          const handle = event.target.classList.contains('clip-handle')
            ? (event.target.classList.contains('left') ? 'trim-left' : 'trim-right')
            : 'move';
          if (handle === 'move' && clip && clip.source === 'recorded') {
            event.preventDefault();
            return;
          }
          state.timeline.drag = {
            type: handle,
            placementId,
            startX: event.clientX,
            startY: event.clientY,
            startStart: placement.timelineStartSeconds,
            startDuration: placement.durationSeconds,
            startClipIn: placement.clipInSeconds,
            lane: placement.lane || 0,
            rectTop: rect.top,
          };
          event.preventDefault();
          return;
        }

        const canvasRect = dom.timelineCanvas.getBoundingClientRect();
        const x = event.clientX - canvasRect.left + dom.timelineViewport.scrollLeft - getLaneHeaderWidth();
        const seconds = snapToBeatGrid(pxToTime(Math.max(0, x)));
        setPlayhead(seconds);
        if (state.timeline.selectionId) {
          state.timeline.selectionId = null;
          renderTimeline();
        }
      }

      function handleTimelineMouseMove(event) {
        if (!state.timeline.drag) return;
        if (!dom.timelineLanes || !dom.timelineViewport) return;
        const drag = state.timeline.drag;
        const placement = getPlacementById(drag.placementId);
        if (!placement) return;
        const clip = getClipById(placement.clipId);
        const deltaPx = event.clientX - drag.startX;
        const deltaSeconds = pxToTime(deltaPx);
        if (drag.type === 'move') {
          if (clip && clip.source === 'recorded') return;
          const newStart = snapToBeatGrid(drag.startStart + deltaSeconds);
          placement.timelineStartSeconds = Math.max(0, newStart);
          const lanesRect = dom.timelineLanes.getBoundingClientRect();
          const y = event.clientY - lanesRect.top + dom.timelineViewport.scrollTop;
          const laneIndex = Math.max(0, Math.min(state.timeline.lanes - 1, Math.floor(y / 54)));
          placement.lane = laneIndex;
        } else if (drag.type === 'trim-left') {
          if (!clip) return;
          const newStart = snapToBeatGrid(drag.startStart + deltaSeconds);
          const maxStart = drag.startStart + drag.startDuration - 0.1;
          const minStart = Math.max(0, drag.startStart - drag.startClipIn);
          const clampedStart = Math.min(maxStart, Math.max(minStart, newStart));
          const delta = clampedStart - drag.startStart;
          const newClipIn = Math.max(0, drag.startClipIn + delta);
          const maxClipIn = Math.max(0, clip.durationSeconds - 0.1);
          placement.timelineStartSeconds = clampedStart;
          placement.clipInSeconds = Math.min(maxClipIn, newClipIn);
          placement.durationSeconds = Math.max(0.1, drag.startDuration - delta);
        } else if (drag.type === 'trim-right') {
          if (!clip) return;
          const newDur = snapToBeatGrid(drag.startDuration + deltaSeconds);
          const maxDur = Math.max(0.1, clip.durationSeconds - placement.clipInSeconds);
          placement.durationSeconds = Math.min(maxDur, Math.max(0.1, newDur));
        }
        placement.clipOutSeconds = placement.clipInSeconds + placement.durationSeconds;
        markDirty();
        renderTimeline();
      }

      function handleTimelineMouseUp() {
        if (!state.timeline.drag) return;
        state.timeline.drag = null;
      }

      async function copyTextToClipboard(text) {
        if (!text) return false;
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (error) {
          const temp = document.createElement('textarea');
          temp.value = text;
          temp.style.position = 'fixed';
          temp.style.opacity = '0';
          document.body.appendChild(temp);
          temp.focus();
          temp.select();
          const ok = document.execCommand('copy');
          temp.remove();
          return ok;
        }
      }

      function getConvertCommand() {
        return 'sh convert-to-mov.sh';
      }

      function updateBpmDisplay() {
        const bpm = getBpm();
        dom.bpmDisplay.textContent = `${bpm.toFixed(1)} BPM`;
        if (!state.timeline.enabled) return;
        if (Math.abs(bpm - state.timeline.lastGridBpm) >= 0.2) {
          state.timeline.lastGridBpm = bpm;
          renderTimeline();
        }
      }

      function populateResolutionOptions() {
        const presets = [
          { label: '640x480', width: 640, height: 480 },
          { label: '1280x720', width: 1280, height: 720 },
          { label: '1920x1080', width: 1920, height: 1080 },
          { label: '2560x1440', width: 2560, height: 1440 },
        ];
        dom.resolutionSelect.innerHTML = '';
        presets.forEach((preset) => {
          const option = document.createElement('option');
          option.value = `${preset.width}x${preset.height}`;
          option.textContent = preset.label;
          dom.resolutionSelect.appendChild(option);
        });
        dom.resolutionSelect.value = '1280x720';
      }

      function updateCameraSourceUI() {
        const isScreen = dom.cameraSelect.value === 'screen';
        dom.resolutionSelect.disabled = isScreen;
      }

      function clearCameraStream(stopTracks = true) {
        if (state.camera.stream && stopTracks) {
          state.camera.stream.getTracks().forEach((track) => track.stop());
        }
        state.camera.stream = null;
        state.camera.source = null;
        dom.liveVideo.srcObject = null;
        dom.liveVideo.style.display = 'none';
        dom.monitorPlaceholder.style.display = 'block';
      }

      async function getCameraStream() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          alert('Camera capture is not supported in this browser.');
          setCameraStatus('blocked');
          return null;
        }
        try {
          const source = dom.cameraSelect.value;
          if (state.camera.stream && state.camera.source === source && state.camera.stream.active) {
            dom.liveVideo.srcObject = state.camera.stream;
            dom.liveVideo.style.display = 'block';
            dom.monitorPlaceholder.style.display = 'none';
            dom.liveVideo.play().catch(() => {});
            setCameraStatus('ready');
            return state.camera.stream;
          }
          if (state.camera.stream) clearCameraStream(true);
          setCameraStatus('busy');
          let stream;
          if (source === 'screen') {
            if (!navigator.mediaDevices.getDisplayMedia) {
              alert('Screen capture is not supported in this browser.');
              setCameraStatus('blocked');
              return null;
            }
            stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
          } else {
            const [width, height] = dom.resolutionSelect.value.split('x').map(Number);
            const deviceId = source || undefined;
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                deviceId: deviceId ? { exact: deviceId } : undefined,
                width: { ideal: width },
                height: { ideal: height },
              },
              audio: false,
            });
          }
          state.camera.stream = stream;
          state.camera.source = source;
          stream.getTracks().forEach((track) => {
            track.onended = () => {
              if (state.camera.stream === stream) {
                clearCameraStream(false);
                setCameraStatus('off');
              }
            };
          });
          dom.liveVideo.srcObject = stream;
          dom.liveVideo.style.display = 'block';
          dom.monitorPlaceholder.style.display = 'none';
          dom.liveVideo.play().catch(() => {});
          setCameraStatus('ready');
          return stream;
        } catch (error) {
          alert(`Unable to access camera: ${error.message}`);
          setCameraStatus('blocked');
          return null;
        }
      }

      async function warmUpCamera(allowScreen = false) {
        if (dom.cameraSelect.value === 'screen' && !allowScreen) {
          setCameraStatus('off');
          return;
        }
        if (state.camera.stream && state.camera.stream.active) {
          setCameraStatus('ready');
          return;
        }
        await getCameraStream();
      }

      function refreshDevices() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          dom.cameraSelect.innerHTML = '<option value="">No devices</option>';
          return;
        }
        navigator.mediaDevices.enumerateDevices().then((devices) => {
          const cameras = devices.filter((device) => device.kind === 'videoinput');
          dom.cameraSelect.innerHTML = '';
          const screenOption = document.createElement('option');
          screenOption.value = 'screen';
          screenOption.textContent = 'Screen / Window Capture';
          dom.cameraSelect.appendChild(screenOption);
          cameras.forEach((camera) => {
            const option = document.createElement('option');
            option.value = camera.deviceId;
            option.textContent = camera.label || `Camera ${dom.cameraSelect.length}`;
            dom.cameraSelect.appendChild(option);
          });
          if (!cameras.length) dom.cameraSelect.value = 'screen';
          updateCameraSourceUI();
        }).catch(() => {
          dom.cameraSelect.innerHTML = '<option value="">Camera list blocked</option>';
        });
      }

      function getSupportedMimeType() {
        const types = [
          'video/webm;codecs=vp9',
          'video/webm;codecs=vp8',
          'video/webm',
        ];
        for (const type of types) {
          if (MediaRecorder.isTypeSupported(type)) return type;
        }
        return '';
      }

      async function ensurePermission(handle) {
        if (!handle) return false;
        if (await handle.queryPermission({ mode: 'readwrite' }) === 'granted') return true;
        return (await handle.requestPermission({ mode: 'readwrite' })) === 'granted';
      }

      async function chooseProjectFolder() {
        if (!window.showDirectoryPicker) {
          alert('File System Access API not available.');
          return;
        }
        state.projectHandle = await window.showDirectoryPicker();
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) alert('Write permission denied for the selected folder.');
        if (!ok) return;
        setExportStatus('Project folder selected.');
        updateFolderStatus();
        await loadProjectFromFolder();
      }

      async function loadProjectFromFolder() {
        if (!state.projectHandle) return;
        state.clips = [];
        state.placements = [];
        state.mediaCache.clear();
        state.mediaHandles.clear();
        state.timeline.selectionId = null;
        state.stage.currentPlacementId = '';

        let mediaDir;
        try {
          mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: true });
        } catch (error) {
          return;
        }

        try {
          for await (const [name, handle] of mediaDir.entries()) {
            if (handle.kind === 'file') {
              state.mediaHandles.set(name, handle);
            }
          }
        } catch (error) {
          // Ignore enumeration errors.
        }

        let xmlText = '';
        try {
          const xmlHandle = await mediaDir.getFileHandle('camorder-stacked-mov.fcpxml');
          const file = await xmlHandle.getFile();
          xmlText = await file.text();
        } catch (error) {
          // Try root folder if media copy does not exist.
        }

        if (!xmlText) {
          try {
            const xmlHandle = await state.projectHandle.getFileHandle('camorder-stacked-mov.fcpxml');
            const file = await xmlHandle.getFile();
            xmlText = await file.text();
          } catch (error) {
            renderTakes();
            renderTimeline();
            renderStageView();
            return;
          }
        }

        const parser = new DOMParser();
        const doc = parser.parseFromString(xmlText, 'application/xml');
        if (doc.querySelector('parsererror')) {
          setExportStatus('Failed to parse existing FCPXML.');
          return;
        }

        const format = doc.querySelector('resources > format');
        if (format) {
          const fps = parseFrameRate(format.getAttribute('frameDuration'));
          if (fps) {
            const rounded = Math.round(fps);
            state.settings.fps = rounded || state.settings.fps;
            if (dom.fpsSelect) dom.fpsSelect.value = String(state.settings.fps);
          }
        }

        const assetMap = new Map();
        const assets = Array.from(doc.querySelectorAll('resources > asset'));
        assets.forEach((asset) => {
          const assetId = asset.getAttribute('id') || makeId('asset');
          const name = asset.getAttribute('name') || assetId;
          const src = asset.getAttribute('src') || '';
          const duration = parseFcpTime(asset.getAttribute('duration'));
          const filename = extractFilenameFromSrc(src) || `${assetId}.mov`;
          const lower = filename.toLowerCase();
          const isWebm = lower.endsWith('.webm');
          const recordedByName = /^clip-[a-z0-9]+\.(webm|mov)$/.test(lower);
          const hasAudio = asset.getAttribute('hasAudio') === '1';
          const clipId = makeId('clip');
          const clip = {
            id: clipId,
            name,
            createdAt: new Date().toISOString(),
            durationSeconds: duration,
            source: (recordedByName || isWebm) ? 'recorded' : 'imported',
            hasAudio,
            filename,
            startSeconds: 0,
          };
          state.clips.push(clip);
          assetMap.set(assetId, clip);
        });

        let maxLane = 0;
        const placements = Array.from(doc.querySelectorAll('spine > asset-clip'));
        placements.forEach((node) => {
          const assetId = node.getAttribute('ref') || '';
          const clip = assetMap.get(assetId);
          if (!clip) return;
          const offset = parseFcpTime(node.getAttribute('offset'));
          const start = parseFcpTime(node.getAttribute('start'));
          const duration = parseFcpTime(node.getAttribute('duration'));
          const lane = parseInt(node.getAttribute('lane') || '0', 10) || 0;
          maxLane = Math.max(maxLane, lane);
          state.placements.push({
            id: makeId('plc'),
            clipId: clip.id,
            timelineStartSeconds: offset,
            clipInSeconds: start,
            clipOutSeconds: start + duration,
            durationSeconds: duration,
            lane,
          });
        });

        state.timeline.lanes = Math.max(state.timeline.lanes, maxLane + 1);
        updateLaneSelect();
        renderTakes();
        renderTimeline();
        renderStageView();

        state.clips.forEach((clip) => {
          ensureClipMedia(clip).then((url) => {
            if (!url) return;
            const cached = state.mediaCache.get(clip.id);
            if (cached && cached.blob && !clip.thumbnail) {
              generateThumbnail(clip, cached.blob).then((thumb) => {
                if (!thumb) return;
                clip.thumbnail = thumb;
                renderTakes();
              });
            }
          });
        });
      }

      async function saveRecordedClipToProject(clip, blob) {
        if (!state.projectHandle) return;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return;
        const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: true });
        const filename = clip.filename || `${clip.id}.webm`;
        clip.filename = filename;
        const handle = await mediaDir.getFileHandle(filename, { create: true });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
      }

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      }

      async function updateProjectFcpxml() {
        if (!state.projectHandle) return;
        const xml = buildStackedFcpXml(true);
        await writeMediaFile('camorder-stacked-mov.fcpxml', xml, 'application/xml');
      }

      async function deleteClipMediaFiles(clipId) {
        const clip = getClipById(clipId);
        if (!clip || clip.source !== 'recorded' || !state.projectHandle) return;
        if (state.clips.some((item) => item.id !== clipId && item.filename === clip.filename)) return;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return;
        const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: true });
        const filenames = new Set();
        if (clip.filename) filenames.add(clip.filename);
        if (clip.filename) {
          const base = clip.filename.replace(/\.[^/.]+$/, '');
          filenames.add(`${base}.webm`);
          filenames.add(`${base}.mov`);
        }
        for (const name of filenames) {
          try {
            await mediaDir.removeEntry(name);
            state.mediaHandles.delete(name);
          } catch (error) {
            if (error && error.name !== 'NotFoundError') {
              console.warn('Failed to remove media file', name, error);
            }
          }
        }
      }

      function maybeDeleteClipMedia(clipId) {
        const remaining = state.placements.filter((placement) => placement.clipId === clipId);
        if (remaining.length === 0) {
          deleteClipMediaFiles(clipId);
          const clipIndex = state.clips.findIndex((clip) => clip.id === clipId);
          if (clipIndex !== -1) {
            state.clips.splice(clipIndex, 1);
          }
          state.mediaCache.delete(clipId);
          renderTakes();
        }
      }

      function sanitizeReelName(name) {
        const base = (name || 'REEL').replace(/\.[^/.]+$/, '');
        const clean = base.replace(/[^a-z0-9]/gi, '_').toUpperCase();
        return clean.slice(0, 8) || 'REEL001';
      }

      function resolveClipFilename(clip, preferMov = false) {
        const raw = clip?.filename || clip?.name || clip?.id || 'clip';
        if (!preferMov) return raw;
        if (clip && clip.source !== 'recorded') return raw;
        const base = raw.replace(/\.[^/.]+$/, '');
        return `${base}.mov`;
      }

      function sanitizeBasePath(path) {
        if (!path) return '';
        let value = path.trim();
        value = value.replace(/^['"]+|['"]+$/g, '');
        if (!value) return '';
        value = value.replace(/\\/g, '/');
        return value.replace(/\/+$/, '');
      }

      function makeFileUrl(path, filename) {
        const base = sanitizeBasePath(path);
        if (!base) return filename;
        let normalized = base;
        let prefix = 'file://';
        if (normalized.startsWith('file://')) {
          normalized = normalized.slice('file://'.length);
          if (normalized.startsWith('localhost/')) {
            normalized = normalized.slice('localhost/'.length);
            prefix = 'file://localhost';
          }
        }
        normalized = normalized.replace(/^\/+/, '/');
        const combined = `${normalized}/${filename}`;
        const encoded = combined.split('/').map(encodeURIComponent).join('/');
        return `${prefix}${encoded}`;
      }

      function parseFcpTime(value) {
        if (!value) return 0;
        const trimmed = value.trim().replace(/s$/, '');
        if (!trimmed) return 0;
        if (trimmed.includes('/')) {
          const [num, den] = trimmed.split('/').map(Number);
          if (Number.isFinite(num) && Number.isFinite(den) && den !== 0) {
            return num / den;
          }
        }
        const numeric = Number(trimmed);
        return Number.isFinite(numeric) ? numeric : 0;
      }

      function parseFrameRate(frameDuration) {
        if (!frameDuration) return 0;
        const trimmed = frameDuration.trim().replace(/s$/, '');
        if (trimmed.includes('/')) {
          const [num, den] = trimmed.split('/').map(Number);
          if (Number.isFinite(num) && Number.isFinite(den) && num !== 0) {
            return den / num;
          }
        }
        return 0;
      }

      function extractFilenameFromSrc(src) {
        if (!src) return '';
        const cleaned = src.replace(/^file:\/\//, '').replace(/^file:\/\/localhost/, '');
        const decoded = decodeURIComponent(cleaned);
        const parts = decoded.split('/');
        return parts[parts.length - 1] || '';
      }

      function getPlacementsForExport() {
        const fps = state.settings.fps;
        const frame = 1 / fps;
        const seen = new Set();
        return state.placements
          .map((placement) => ({
            ...placement,
            end: placement.timelineStartSeconds + placement.durationSeconds,
          }))
          .filter((placement) => placement.durationSeconds > frame)
          .filter((placement) => {
            const key = [
              placement.clipId,
              placement.timelineStartSeconds.toFixed(3),
              placement.durationSeconds.toFixed(3),
              placement.clipInSeconds.toFixed(3),
            ].join('|');
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });
      }

      function buildStackedFcpXml(preferMp4 = true) {
        const fps = state.settings.fps;
        const placements = getPlacementsForExport().sort((a, b) => a.timelineStartSeconds - b.timelineStartSeconds);
        const items = placements.map((placement) => ({
          ...placement,
          lane: typeof placement.lane === 'number' ? placement.lane : 0,
        }));

        const usedClipIds = new Set(items.map((item) => item.clipId));
        const formatId = 'r1';
        const formatWidth = 1920;
        const formatHeight = 1080;
        const frameDuration = `1/${fps}s`;
        const totalDuration = secondsToFcpDuration(getTimelineDurationSeconds(), fps);

        const assetLines = [];
        Array.from(usedClipIds).forEach((clipId, index) => {
          const clip = getClipById(clipId);
          if (!clip) return;
          const assetId = `r${index + 2}`;
          const filename = resolveClipFilename(clip, preferMp4);
          const src = makeFileUrl(state.export.mediaBasePath, filename);
          const duration = secondsToFcpDuration(Math.max(clip.durationSeconds, 0), fps);
          const audioFlag = clip.hasAudio ? '1' : '0';
          const safeName = (clip.name || clip.id).replace(/\"/g, '');
          assetLines.push(
            `    <asset id=\"${assetId}\" name=\"${safeName}\" src=\"${src}\" start=\"0s\" duration=\"${duration}\" hasVideo=\"1\" hasAudio=\"${audioFlag}\" format=\"${formatId}\"/>`
          );
          clip.__assetId = assetId;
        });

        const spineLines = [];
        items.forEach((item) => {
          const clip = getClipById(item.clipId);
          if (!clip) return;
          const assetId = clip.__assetId;
          const clipName = (clip.name || clip.id).replace(/\"/g, '');
          const clipIn = snapSeconds(item.clipInSeconds, fps);
          const duration = snapSeconds(item.durationSeconds, fps);
          const offset = secondsToFcpDuration(item.timelineStartSeconds, fps);
          const start = secondsToFcpDuration(clipIn, fps);
          const dur = secondsToFcpDuration(duration, fps);
          const laneAttr = item.lane > 0 ? ` lane=\"${item.lane}\"` : '';
          spineLines.push(
            `          <asset-clip name=\"${clipName}\" ref=\"${assetId}\" offset=\"${offset}\" start=\"${start}\" duration=\"${dur}\"${laneAttr}/>`
          );
        });

        const xml = [
          '<?xml version="1.0" encoding="UTF-8"?>',
          '<fcpxml version="1.9">',
          '  <resources>',
          `    <format id=\"${formatId}\" name=\"CamOrderFormat\" frameDuration=\"${frameDuration}\" width=\"${formatWidth}\" height=\"${formatHeight}\"/>`,
          assetLines.join('\n'),
          '  </resources>',
          '  <library>',
          '    <event name="CamOrder">',
          '      <project name="CamOrder">',
          `        <sequence format=\"${formatId}\" duration=\"${totalDuration}\" tcStart=\"0s\" tcFormat=\"NDF\">`,
          '          <spine>',
          spineLines.join('\n'),
          '          </spine>',
          '        </sequence>',
          '      </project>',
          '    </event>',
          '  </library>',
          '</fcpxml>',
        ].filter((line) => line !== '').join('\n');

        Array.from(usedClipIds).forEach((clipId) => {
          const clip = getClipById(clipId);
          if (clip && clip.__assetId) delete clip.__assetId;
        });

        return xml;
      }

      function buildFlatFcpXml(preferMp4 = true) {
        const fps = state.settings.fps;
        const segments = buildFlatSegments();
        const usedClipIds = new Set();
        segments.forEach((segment) => {
          const placement = getPlacementById(segment.placementId);
          if (placement) usedClipIds.add(placement.clipId);
        });

        const formatId = 'r1';
        const formatWidth = 1920;
        const formatHeight = 1080;
        const frameDuration = `1/${fps}s`;
        const totalDuration = secondsToFcpDuration(getTimelineDurationSeconds(), fps);

        const assetLines = [];
        Array.from(usedClipIds).forEach((clipId, index) => {
          const clip = getClipById(clipId);
          if (!clip) return;
          const assetId = `r${index + 2}`;
          const filename = resolveClipFilename(clip, preferMp4);
          const src = makeFileUrl(state.export.mediaBasePath, filename);
          const duration = secondsToFcpDuration(Math.max(clip.durationSeconds, 0), fps);
          const audioFlag = clip.hasAudio ? '1' : '0';
          const safeName = (clip.name || clip.id).replace(/\"/g, '');
          assetLines.push(
            `    <asset id=\"${assetId}\" name=\"${safeName}\" src=\"${src}\" start=\"0s\" duration=\"${duration}\" hasVideo=\"1\" hasAudio=\"${audioFlag}\" format=\"${formatId}\"/>`
          );
          clip.__assetId = assetId;
        });

        const spineLines = [];
        segments.forEach((segment) => {
          const placement = getPlacementById(segment.placementId);
          if (!placement) return;
          const clip = getClipById(placement.clipId);
          if (!clip) return;
          const assetId = clip.__assetId;
          const clipName = (clip.name || clip.id).replace(/\"/g, '');
          const segStart = snapSeconds(segment.start, fps);
          const segEnd = snapSeconds(segment.end, fps);
          const clipIn = snapSeconds(placement.clipInSeconds + (segStart - placement.timelineStartSeconds), fps);
          const clipOut = snapSeconds(clipIn + (segEnd - segStart), fps);
          const offset = secondsToFcpDuration(segStart, fps);
          const start = secondsToFcpDuration(clipIn, fps);
          const duration = secondsToFcpDuration(clipOut - clipIn, fps);
          spineLines.push(
            `          <asset-clip name=\"${clipName}\" ref=\"${assetId}\" offset=\"${offset}\" start=\"${start}\" duration=\"${duration}\"/>`
          );
        });

        const xml = [
          '<?xml version="1.0" encoding="UTF-8"?>',
          '<fcpxml version="1.9">',
          '  <resources>',
          `    <format id=\"${formatId}\" name=\"CamOrderFormat\" frameDuration=\"${frameDuration}\" width=\"${formatWidth}\" height=\"${formatHeight}\"/>`,
          assetLines.join('\n'),
          '  </resources>',
          '  <library>',
          '    <event name="CamOrder">',
          '      <project name="CamOrder">',
          `        <sequence format=\"${formatId}\" duration=\"${totalDuration}\" tcStart=\"0s\" tcFormat=\"NDF\">`,
          '          <spine>',
          spineLines.join('\n'),
          '          </spine>',
          '        </sequence>',
          '      </project>',
          '    </event>',
          '  </library>',
          '</fcpxml>',
        ].filter((line) => line !== '').join('\n');

        Array.from(usedClipIds).forEach((clipId) => {
          const clip = getClipById(clipId);
          if (clip && clip.__assetId) delete clip.__assetId;
        });

        return xml;
      }

      function buildFlatSegments() {
        const placements = getPlacementsForExport();
        const boundaries = new Set();
        placements.forEach((placement) => {
          boundaries.add(placement.timelineStartSeconds);
          boundaries.add(placement.end);
        });
        const times = Array.from(boundaries).sort((a, b) => a - b);
        const segments = [];

        for (let i = 0; i < times.length - 1; i += 1) {
          const start = times[i];
          const end = times[i + 1];
          if (end <= start) continue;
          const mid = (start + end) / 2;
          const active = placements.filter((placement) => mid >= placement.timelineStartSeconds && mid < placement.end);
          if (!active.length) continue;
          active.sort((a, b) => a.timelineStartSeconds - b.timelineStartSeconds);
          const top = active[active.length - 1];
          const last = segments[segments.length - 1];
          if (last && last.placementId === top.id) {
            last.end = end;
          } else {
            segments.push({ placementId: top.id, start, end });
          }
        }

        return segments;
      }

      function buildFlatEdl(preferMp4 = true) {
        const fps = state.settings.fps;
        const segments = buildFlatSegments();
        const lines = [];
        lines.push('TITLE: CamOrder Flattened');
        lines.push('FCM: NON-DROP FRAME');

        segments.forEach((segment, index) => {
          const placement = getPlacementById(segment.placementId);
          if (!placement) return;
          const clip = getClipById(placement.clipId);
          const filename = resolveClipFilename(clip, preferMp4);
          const reel = sanitizeReelName(filename);
          const segStart = snapSeconds(segment.start, fps);
          const segEnd = snapSeconds(segment.end, fps);
          const clipIn = snapSeconds(placement.clipInSeconds + (segStart - placement.timelineStartSeconds), fps);
          const clipOut = snapSeconds(clipIn + (segEnd - segStart), fps);
          const recIn = secondsToSMPTE(segStart, fps);
          const recOut = secondsToSMPTE(segEnd, fps);
          const srcIn = secondsToSMPTE(clipIn, fps);
          const srcOut = secondsToSMPTE(clipOut, fps);
          const eventNum = pad(index + 1, 3);
          lines.push(`${eventNum}  ${reel.padEnd(8)} V     C        ${srcIn} ${srcOut} ${recIn} ${recOut}`);
          lines.push(`* FROM CLIP NAME: ${filename}`);
        });

        if (!segments.length) {
          lines.push('* (No placements to export)');
        }

        return lines.join('\n');
      }

      function buildFfmpegScriptSh() {
        return [
          '#!/bin/sh',
          'set -e',
          'mkdir -p media',
          'for f in media/*.webm; do',
          '  [ -e "$f" ] || continue',
          '  base=$(basename "$f" .webm)',
          '  ffmpeg -y -i "$f" -map 0:v -map 0:a? -c:v prores_ks -profile:v 3 -pix_fmt yuv422p10le -c:a pcm_s16le "media/${base}.mov"',
          '  rm -f "$f"',
          'done',
        ].join('\n');
      }

      async function writeProjectFile(filename, content, contentType = 'text/plain') {
        if (!state.projectHandle) return false;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return false;
        const handle = await state.projectHandle.getFileHandle(filename, { create: true });
        const writable = await handle.createWritable();
        await writable.write(new Blob([content], { type: contentType }));
        await writable.close();
        return true;
      }

      async function writeMediaFile(filename, content, contentType = 'text/plain') {
        if (!state.projectHandle) return false;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return false;
        const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: true });
        const handle = await mediaDir.getFileHandle(filename, { create: true });
        const writable = await handle.createWritable();
        await writable.write(new Blob([content], { type: contentType }));
        await writable.close();
        return true;
      }

      async function removeExportArtifacts() {
        if (!state.projectHandle || !state.projectHandle.removeEntry) return;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return;
        const files = [
          'camorder-stacked-mov.fcpxml',
          'convert-to-mov.sh',
        ];
        for (const filename of files) {
          try {
            await state.projectHandle.removeEntry(filename);
          } catch (error) {
            if (error && error.name !== 'NotFoundError') {
              console.warn('Failed to remove export file', filename, error);
            }
          }
        }
        try {
          const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: false });
          await mediaDir.removeEntry('camorder-stacked-mov.fcpxml');
        } catch (error) {
          if (error && error.name !== 'NotFoundError') {
            console.warn('Failed to remove media export file', error);
          }
        }
      }

      async function exportResolvePackage() {
        if (window.showDirectoryPicker && !state.projectHandle) {
          await chooseProjectFolder();
        }
        if (!state.projectHandle && window.showDirectoryPicker) {
          setExportStatus('Export canceled. Choose a project folder first.');
          updateFolderStatus();
          return;
        }
        let hasExisting = false;
        if (state.projectHandle) {
          try {
            const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: false });
            await mediaDir.getFileHandle('camorder-stacked-mov.fcpxml');
            hasExisting = true;
          } catch (error) {
            try {
              await state.projectHandle.getFileHandle('camorder-stacked-mov.fcpxml');
              hasExisting = true;
            } catch (innerError) {
              // Not found.
            }
          }
          await removeExportArtifacts();
        }
        const fcpxmlMov = buildStackedFcpXml(true);
        const xmlMovName = 'camorder-stacked-mov.fcpxml';

        if (state.projectHandle) {
          await writeMediaFile(xmlMovName, fcpxmlMov, 'application/xml');
          await writeProjectFile('convert-to-mov.sh', buildFfmpegScriptSh(), 'text/x-shellscript');
        } else {
          downloadBlob(new Blob([fcpxmlMov], { type: 'application/xml' }), xmlMovName);
          downloadBlob(new Blob([buildFfmpegScriptSh()], { type: 'text/x-shellscript' }), 'convert-to-mov.sh');
        }
        const hint = getConvertCommand();
        if (hint) {
          const copied = await copyTextToClipboard(hint);
          setExportStatus(
            copied
              ? 'Resolve package exported. Convert command copied to clipboard.'
              : 'Resolve package exported. Use the Copy button in the Project panel.'
          );
        } else {
          setExportStatus('Resolve package exported. Convert command unavailable for this folder selection.');
        }
        setExportBadge(hasExisting ? 'updated' : 'exported');
      }

      function getClipById(clipId) {
        return state.clips.find((clip) => clip.id === clipId);
      }

      function getPlacementById(placementId) {
        return state.placements.find((placement) => placement.id === placementId);
      }

      function getTimelineDurationSeconds() {
        let maxEnd = 0;
        for (const placement of state.placements) {
          const end = placement.timelineStartSeconds + placement.durationSeconds;
          if (end > maxEnd) maxEnd = end;
        }
        return Math.max(0, maxEnd);
      }

      async function startRecording() {
        if (state.recording.active || state.recording.pending) return;
        if (!state.projectHandle) {
          setExportStatus('Choose a project folder before recording.');
          updateFolderStatus();
          return;
        }
        if (!state.armed) return;

        state.recording.pending = true;
        const stream = await getRecordingStream();
        if (!stream) {
          state.recording.pending = false;
          return;
        }

        const rawStart = state.playheadSeconds;
        const recordStart = state.timeline.enabled
          ? snapToBeatGridCeil(rawStart)
          : Math.max(0, snapSeconds(rawStart, state.settings.fps));
        const clipInSeconds = state.timeline.enabled
          ? Math.max(0, recordStart - rawStart)
          : 0;
        const mimeType = getSupportedMimeType();
        const extension = 'webm';
        const clipId = makeId('clip');
        const clipName = `Take ${pad(state.clips.length + 1, 3)} ${secondsToSMPTE(recordStart, state.settings.fps)}`;
        const hasAudio = stream.getAudioTracks().length > 0;
        const clip = {
          id: clipId,
          name: clipName,
          createdAt: new Date().toISOString(),
          durationSeconds: 0,
          source: 'recorded',
          hasAudio,
          filename: `${clipId}.${extension}`,
          startSeconds: rawStart,
        };
        state.clips.push(clip);

        const placement = {
          id: makeId('plc'),
          clipId,
          timelineStartSeconds: recordStart,
          clipInSeconds,
          clipOutSeconds: clipInSeconds,
          durationSeconds: 0,
          lane: state.timeline.selectedLane || 0,
        };
        state.placements.push(placement);

        const recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
        const chunks = [];
        recorder.ondataavailable = (event) => {
          if (event.data.size > 0) chunks.push(event.data);
        };
        recorder.onstop = () => {
          finalizeRecording({ clipId, chunks, mimeType, placementId: placement.id, stream });
        };
        recorder.start(200);

        state.recording = {
          active: true,
          pending: false,
          clipId,
          startPlayhead: rawStart,
          recorder,
          chunks,
        };
        setRecordStatus('recording');
        setCameraStatus('live');
      }

      function updateRecordingDuration() {
        if (!state.recording.active) return;
        const rawDuration = Math.max(0, state.playheadSeconds - state.recording.startPlayhead);
        const placement = state.placements.find((item) => item.clipId === state.recording.clipId);
        const usableDuration = placement
          ? Math.max(0, rawDuration - placement.clipInSeconds)
          : rawDuration;
        const snappedDuration = state.timeline.enabled
          ? Math.min(usableDuration, snapToBeatGrid(usableDuration))
          : snapSeconds(usableDuration, state.settings.fps);
        if (placement) {
          placement.durationSeconds = snappedDuration;
          placement.clipOutSeconds = placement.clipInSeconds + snappedDuration;
        }
        updateTimelineRecordingClip();
      }

      function generateThumbnail(clip, blob) {
        return new Promise((resolve) => {
          const url = URL.createObjectURL(blob);
          const video = document.createElement('video');
          video.preload = 'metadata';
          video.muted = true;
          video.src = url;

          const cleanup = () => {
            URL.revokeObjectURL(url);
          };

          video.addEventListener('loadedmetadata', () => {
            const target = Number.isFinite(video.duration) && video.duration > 0 ? Math.min(0.1, video.duration / 2) : 0;
            try {
              video.currentTime = target;
            } catch (error) {
              cleanup();
              resolve('');
            }
          }, { once: true });

          video.addEventListener('seeked', () => {
            const canvas = document.createElement('canvas');
            const width = video.videoWidth || 160;
            const height = video.videoHeight || 90;
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (ctx) ctx.drawImage(video, 0, 0, width, height);
            cleanup();
            resolve(canvas.toDataURL('image/jpeg', 0.7));
          }, { once: true });

          video.addEventListener('error', () => {
            cleanup();
            resolve('');
          }, { once: true });
        });
      }

      function finalizeRecording(recording) {
        const clip = getClipById(recording.clipId);
        if (!clip) return;
        const blob = new Blob(recording.chunks, { type: recording.mimeType || 'video/webm' });
        const rawDuration = Math.max(0, state.playheadSeconds - clip.startSeconds);
        const placement = state.placements.find((item) => item.clipId === clip.id);
        const usableDuration = placement
          ? Math.max(0, rawDuration - placement.clipInSeconds)
          : rawDuration;
        const snappedDuration = state.timeline.enabled
          ? Math.min(usableDuration, snapToBeatGrid(usableDuration))
          : snapSeconds(usableDuration, state.settings.fps);
        clip.durationSeconds = rawDuration;
        if (placement) {
          placement.durationSeconds = snappedDuration;
          placement.clipOutSeconds = placement.clipInSeconds + placement.durationSeconds;
        }
        const url = URL.createObjectURL(blob);
        state.mediaCache.set(clip.id, { blob, url, filename: clip.filename });
        if (state.projectHandle) {
          saveRecordedClipToProject(clip, blob).catch((error) => {
            console.warn('Failed to save clip to project folder', error);
          });
        }
        if (!state.dawless.enabled && (!state.camera.stream || recording.stream !== state.camera.stream)) {
          recording.stream.getTracks().forEach((track) => track.stop());
        }
        state.recording = { active: false, pending: false, clipId: null, startPlayhead: 0, recorder: null, chunks: [] };
        setRecordStatus(state.armed ? 'armed' : 'idle');
        setCameraStatus(state.camera.stream && state.camera.stream.active ? 'ready' : 'off');
        markDirty();
        renderTakes();
        renderTimeline();
        generateThumbnail(clip, blob).then((thumb) => {
          if (!thumb) return;
          clip.thumbnail = thumb;
          renderTakes();
        });
        renderStageView();
      }

      function stopRecording() {
        if (!state.recording.active) return;
        const { recorder } = state.recording;
        if (recorder && recorder.state !== 'inactive') {
          recorder.stop();
        }
      }

      function renderTakes() {
        dom.takesList.innerHTML = '';
        if (!state.clips.length) {
          const empty = document.createElement('div');
          empty.className = 'take-meta';
          empty.textContent = 'No takes recorded yet.';
          dom.takesList.appendChild(empty);
          return;
        }
        const fragment = document.createDocumentFragment();
        state.clips.forEach((clip) => {
          const placement = state.placements.find((item) => item.clipId === clip.id);
          const item = document.createElement('div');
          item.className = 'take-item';
          const thumb = document.createElement('div');
          thumb.className = 'take-thumb';
          if (clip.thumbnail) {
            thumb.style.backgroundImage = `url(${clip.thumbnail})`;
          }
          const info = document.createElement('div');
          info.className = 'take-info';
          const title = document.createElement('div');
          title.className = 'take-title';
          title.textContent = clip.name;
          const meta = document.createElement('div');
          meta.className = 'take-meta';
          const startTc = secondsToSMPTE(clip.startSeconds || 0, state.settings.fps);
          const dur = placement ? placement.durationSeconds : clip.durationSeconds;
          meta.textContent = `Start ${startTc} | ${dur.toFixed(2)}s | ${clip.filename}`;
          const actions = document.createElement('div');
          actions.className = 'take-actions';
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'ghost take-delete';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            deleteClipAndPlacements(clip.id);
          });
          actions.appendChild(deleteBtn);
          info.appendChild(title);
          info.appendChild(meta);
          info.appendChild(actions);
          item.appendChild(thumb);
          item.appendChild(info);
          fragment.appendChild(item);
        });
        dom.takesList.appendChild(fragment);
      }

      function deleteClipAndPlacements(clipId) {
        const clipIndex = state.clips.findIndex((clip) => clip.id === clipId);
        if (clipIndex === -1) return;
        state.clips.splice(clipIndex, 1);
        state.placements = state.placements.filter((placement) => placement.clipId !== clipId);
        if (state.timeline.selectionId) {
          const stillExists = state.placements.some((placement) => placement.id === state.timeline.selectionId);
          if (!stillExists) state.timeline.selectionId = null;
        }
        const cached = state.mediaCache.get(clipId);
        if (cached && cached.url) URL.revokeObjectURL(cached.url);
        state.mediaCache.delete(clipId);
        deleteClipMediaFiles(clipId);
        markDirty();
        renderTakes();
        renderTimeline();
        renderStageView();
        updateProjectFcpxml();
      }

      function pickPreferredMidiInput(inputs) {
        if (!inputs.length) return '';
        const priority = [/logic/i, /iac/i, /virtual/i, /bus/i];
        for (const pattern of priority) {
          const match = inputs.find((input) => pattern.test(input.name || ''));
          if (match) return match.id;
        }
        return inputs[0].id;
      }

      function refreshMidiInputs() {
        if (!state.midi.access) return;
        const inputs = Array.from(state.midi.access.inputs.values());
        const currentSelection = dom.midiInputSelect.value;
        dom.midiInputSelect.innerHTML = '';
        if (!inputs.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No MIDI inputs';
          dom.midiInputSelect.appendChild(opt);
          return;
        }
        inputs.forEach((input) => {
          const opt = document.createElement('option');
          opt.value = input.id;
          opt.textContent = input.name || input.id;
          dom.midiInputSelect.appendChild(opt);
        });
        if (currentSelection && inputs.some((input) => input.id === currentSelection)) {
          dom.midiInputSelect.value = currentSelection;
        } else {
          dom.midiInputSelect.value = pickPreferredMidiInput(inputs);
        }
      }

      async function requestMidiAccess() {
        if (!navigator.requestMIDIAccess) {
          setMidiStatus('warn', 'MIDI Unsupported');
          return null;
        }
        try {
          const access = await navigator.requestMIDIAccess();
          return access;
        } catch (error) {
          console.warn('MIDI access error', error);
          setMidiStatus('warn', 'MIDI Blocked');
          return null;
        }
      }

      function disconnectMidi() {
        if (state.midi.input) {
          state.midi.input.onmidimessage = null;
        }
        state.midi.input = null;
        state.midi.connected = false;
        state.midi.clock.playing = false;
        dom.midiConnectBtn.textContent = 'Enable MIDI';
        setMidiStatus('ready', 'MIDI Ready');
        setRecordStatus(state.armed ? 'armed' : 'idle');
      }

      async function connectMidi() {
        if (state.midi.connected) {
          disconnectMidi();
          return;
        }
        if (!state.midi.access) {
          state.midi.access = await requestMidiAccess();
          if (!state.midi.access) return;
          state.midi.access.onstatechange = refreshMidiInputs;
        }
        refreshMidiInputs();
        const inputId = dom.midiInputSelect.value;
        const input = Array.from(state.midi.access.inputs.values()).find((item) => item.id === inputId);
        if (!input) {
          setMidiStatus('warn', 'No MIDI Input');
          return;
        }
        state.midi.input = input;
        state.midi.input.onmidimessage = handleMidiMessage;
        state.midi.connected = true;
        state.midi.clock.lastTick = 0;
        state.midi.clock.playing = false;
        dom.midiConnectBtn.textContent = 'Disable MIDI';
        setMidiStatus('connected', input.name || 'MIDI Connected');
        setRecordStatus(state.armed ? 'armed' : 'idle');
      }

      function handleSongPositionPointer(lsb, msb) {
        const spp = (msb << 7) | lsb;
        const bpm = Math.max(20, state.midi.clock.bpm || 120);
        const seconds = (spp * 60) / (bpm * 4);
        state.midi.clock.songPositionSeconds = seconds;
        setPlayhead(seconds);
      }

      function handleMidiClockTick(timeStamp) {
        const lastTick = state.midi.clock.lastTick;
        if (lastTick) {
          const delta = Math.max(0.001, (timeStamp - lastTick) / 1000);
          const bpm = 60 / (delta * 24);
          if (Number.isFinite(bpm) && bpm >= 20 && bpm <= 300) {
            state.midi.clock.bpm = state.midi.clock.bpm * 0.85 + bpm * 0.15;
            updateBpmDisplay();
          }
        }
        state.midi.clock.lastTick = timeStamp;
        if (!state.midi.clock.playing) return;
        const tickSeconds = 60 / (state.midi.clock.bpm * 24);
        setPlayhead(state.playheadSeconds + tickSeconds);
        updateRecordingDuration();
        if (canAutoRecord()) {
          if (!state.recording.active && !state.recording.pending) {
            startRecording();
          }
        }
      }

      function handleMidiMessage(event) {
        if (state.dawless.enabled) return;
        const data = event.data;
        const status = data[0];
        if (status === 0xF8) {
          handleMidiClockTick(event.timeStamp);
          return;
        }
        if (status === 0xFA) {
          state.midi.clock.playing = true;
          setPlayhead(state.midi.clock.songPositionSeconds || 0);
          return;
        }
        if (status === 0xFB) {
          state.midi.clock.playing = true;
          return;
        }
        if (status === 0xFC) {
          state.midi.clock.playing = false;
          if (state.recording.active) stopRecording();
          return;
        }
        if (status === 0xF2 && data.length > 2) {
          handleSongPositionPointer(data[1], data[2]);
        }
      }

      function updateArmedUi() {
        dom.armBtn.textContent = state.armed ? 'Armed' : 'Arm Recorder';
        dom.armBtn.classList.toggle('danger', state.armed);
        setRecordStatus(state.recording.active ? 'recording' : (state.armed ? 'armed' : 'idle'));
      }

      function canAutoRecord() {
        return Boolean(
          state.armed &&
          state.projectHandle &&
          state.camera.stream &&
          state.camera.stream.active &&
          isTransportPlaying()
        );
      }

      function updateFps() {
        state.settings.fps = parseInt(dom.fpsSelect.value, 10);
        setPlayhead(state.playheadSeconds);
        renderTakes();
        renderTimeline();
      }

      function setupEvents() {
        dom.midiConnectBtn.addEventListener('click', connectMidi);
        dom.midiInputSelect.addEventListener('change', () => {
          if (state.midi.connected) {
            disconnectMidi();
            connectMidi();
          }
        });
        dom.armBtn.addEventListener('click', () => {
          state.armed = !state.armed;
          updateArmedUi();
        });
        dom.fpsSelect.addEventListener('change', updateFps);
        dom.enableCameraBtn.addEventListener('click', () => warmUpCamera(true));
        dom.refreshDevices.addEventListener('click', refreshDevices);
        dom.cameraSelect.addEventListener('change', () => {
          clearCameraStream(true);
          setCameraStatus('off');
          updateCameraSourceUI();
        });
        dom.resolutionSelect.addEventListener('change', () => {
          clearCameraStream(true);
          setCameraStatus('off');
        });
        dom.chooseFolderBtn.addEventListener('click', chooseProjectFolder);
        dom.exportPackageBtn.addEventListener('click', exportResolvePackage);
        if (dom.copyConvertBtn) {
          dom.copyConvertBtn.addEventListener('click', async () => {
            const value = getConvertCommand();
            const copied = await copyTextToClipboard(value);
            if (copied) setExportStatus('Convert command copied to clipboard.');
          });
        }
        if (dom.toggleDawlessBtn) {
          dom.toggleDawlessBtn.addEventListener('click', () => {
            setDawlessEnabled(!state.dawless.enabled);
          });
        }
        if (dom.dawlessPlayBtn) {
          dom.dawlessPlayBtn.addEventListener('click', () => {
            if (!state.dawless.enabled) return;
            if (state.dawless.playing) {
              stopDawlessTransport();
            } else {
              startDawlessTransport();
            }
          });
        }
        if (dom.metronomeBtn) {
          dom.metronomeBtn.addEventListener('click', () => {
            if (!state.dawless.enabled) return;
            state.dawless.metronomeOn = !state.dawless.metronomeOn;
            dom.metronomeBtn.classList.toggle('toggle-active', state.dawless.metronomeOn);
          });
        }
        if (dom.tempoInput) {
          dom.tempoInput.addEventListener('change', () => {
            const next = parseFloat(dom.tempoInput.value);
            if (!Number.isFinite(next)) return;
            state.dawless.tempoBpm = Math.min(240, Math.max(40, next));
            dom.tempoInput.value = String(state.dawless.tempoBpm);
            updateBpmDisplay();
            renderTimeline();
          });
        }
        if (dom.audioInputSelect) {
          dom.audioInputSelect.addEventListener('change', () => {
            state.dawless.audioInputId = dom.audioInputSelect.value;
            stopAudioStream();
          });
        }
        if (dom.refreshAudioBtn) {
          dom.refreshAudioBtn.addEventListener('click', () => refreshAudioInputs(true));
        }
        if (dom.toggleTimelineBtn) {
        dom.toggleTimelineBtn.addEventListener('click', () => {
          state.timeline.enabled = !state.timeline.enabled;
          document.getElementById('app').classList.toggle('timeline-enabled', state.timeline.enabled);
          if (!state.timeline.enabled && state.dawless.enabled) {
            setDawlessEnabled(false);
          }
          if (state.timeline.enabled) {
            setTimelineHeight(parseInt(getComputedStyle(document.getElementById('app')).getPropertyValue('--timeline-height'), 10) || 260);
          }
          dom.toggleTimelineBtn.textContent = state.timeline.enabled
            ? 'Hide Video Timeline'
            : 'Video Timeline';
          state.timeline.lastGridBpm = getBpm();
          if (dom.takesHeader) {
            dom.takesHeader.textContent = state.timeline.enabled ? 'Stage' : 'Takes';
          }
          moveProjectBlock();
          renderTimeline();
          updateTimelinePlayhead();
          renderStageView();
        });
      }
        if (dom.timelineResizeHandle) {
          dom.timelineResizeHandle.addEventListener('mousedown', (event) => {
            if (!state.timeline.enabled) return;
            event.preventDefault();
            const startY = event.clientY;
            const current = parseInt(getComputedStyle(document.getElementById('app')).getPropertyValue('--timeline-height'), 10) || 260;
            const onMove = (moveEvent) => {
              const delta = moveEvent.clientY - startY;
              setTimelineHeight(current - delta);
            };
            const onUp = () => {
              window.removeEventListener('mousemove', onMove);
              window.removeEventListener('mouseup', onUp);
            };
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
          });
        }
        if (dom.laneSelect) {
          dom.laneSelect.addEventListener('change', () => {
            state.timeline.selectedLane = parseInt(dom.laneSelect.value, 10) || 0;
          });
        }
        if (dom.addLaneBtn) {
          dom.addLaneBtn.addEventListener('click', () => {
            state.timeline.lanes += 1;
            updateLaneSelect();
            renderTimeline();
          });
        }
        if (dom.deletePlacementBtn) {
          dom.deletePlacementBtn.addEventListener('click', deleteSelectedPlacement);
        }
        if (dom.timelineViewport) {
          dom.timelineViewport.addEventListener('mousedown', handleTimelineMouseDown);
        }
        window.addEventListener('mousemove', handleTimelineMouseMove);
        window.addEventListener('mouseup', handleTimelineMouseUp);
        window.addEventListener('keydown', (event) => {
          if (!state.timeline.enabled) return;
          if (event.target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) return;
          if (event.key === 'Delete' || event.key === 'Backspace') {
            deleteSelectedPlacement();
          }
        });
        dom.liveVideo.addEventListener('loadedmetadata', () => {
          dom.liveVideo.play().catch(() => {});
        });

        window.addEventListener('beforeunload', (event) => {
          if (!state.dirty) return;
          event.preventDefault();
          event.returnValue = '';
        });
      }

      function init() {
        cacheDom();
        setupEvents();
        populateResolutionOptions();
        refreshDevices();
        refreshAudioInputs();
        if (dom.tempoInput) dom.tempoInput.value = String(state.dawless.tempoBpm);
        if (dom.stageVideo) dom.stageVideo.muted = !state.dawless.enabled;
        setCameraStatus('off');
        updateExportNotes();
        updateFolderStatus();
        updateBpmDisplay();
        updateArmedUi();
        setDawlessEnabled(state.dawless.enabled);
        setTimelineHeight(260);
        renderTakes();
        updateLaneSelect();
        document.getElementById('app').classList.toggle('timeline-enabled', state.timeline.enabled);
        if (dom.toggleTimelineBtn) {
          dom.toggleTimelineBtn.textContent = state.timeline.enabled
            ? 'Hide Video Timeline'
            : 'Video Timeline';
        }
        if (dom.takesHeader) {
          dom.takesHeader.textContent = state.timeline.enabled ? 'Stage' : 'Takes';
        }
        moveProjectBlock();
        if (navigator.requestMIDIAccess) {
          setMidiStatus('ready', 'MIDI Ready');
          requestMidiAccess().then((access) => {
            if (!access) return;
            state.midi.access = access;
            state.midi.access.onstatechange = refreshMidiInputs;
            refreshMidiInputs();
          });
        } else {
          setMidiStatus('warn', 'MIDI Unsupported');
          dom.midiConnectBtn.disabled = true;
          dom.midiInputSelect.disabled = true;
        }
      }

      window.addEventListener('load', init);
    })();
  </script>
</body>
</html>
