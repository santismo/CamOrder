<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CamOrder Recorder</title>
  <style>
    :root {
      --bg-0: #0e1217;
      --bg-1: #141a21;
      --panel: #1b222b;
      --panel-hi: #222c37;
      --panel-edge: #2c3744;
      --text: #e6ecf3;
      --muted: #98a6b3;
      --accent: #4ad38a;
      --accent-2: #3aa2ff;
      --danger: #ff4d4d;
      --warning: #f2c94c;
      --shadow: rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Trebuchet MS", "Lucida Sans Unicode", "Tahoma", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(58, 162, 255, 0.12), transparent 60%),
        radial-gradient(900px 500px at 85% 15%, rgba(74, 211, 138, 0.12), transparent 65%),
        linear-gradient(160deg, var(--bg-0), var(--bg-1));
      height: 100vh;
      overflow: hidden;
    }

    #app {
      height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      padding: 12px;
    }

    #topbar {
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: linear-gradient(180deg, var(--panel-hi), var(--panel));
      border: 1px solid var(--panel-edge);
      border-radius: 12px;
      box-shadow: 0 8px 20px var(--shadow);
      min-height: 64px;
    }

    #brand {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #brand h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 1px;
    }

    #brand span {
      font-size: 12px;
      color: var(--muted);
    }

    #statusRow {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    #timeRow {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: flex-end;
    }

    #timeDisplay {
      font-family: "Lucida Console", "Courier New", monospace;
      font-size: 13px;
      background: #0f141a;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #26303b;
    }

    #bpmDisplay {
      font-size: 12px;
      color: var(--muted);
    }

    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.4px;
      background: rgba(152, 166, 179, 0.1);
      color: var(--muted);
      border: 1px solid rgba(152, 166, 179, 0.3);
    }

    .pill.live {
      background: rgba(74, 211, 138, 0.2);
      color: var(--accent);
      border-color: rgba(74, 211, 138, 0.4);
    }

    .pill.recording {
      background: rgba(255, 77, 77, 0.2);
      color: var(--danger);
      border-color: rgba(255, 77, 77, 0.4);
    }

    .pill.warn {
      background: rgba(242, 201, 76, 0.2);
      color: var(--warning);
      border-color: rgba(242, 201, 76, 0.4);
    }

    #content {
      display: grid;
      grid-template-columns: 280px 1fr 320px;
      gap: 10px;
      min-height: 0;
    }

    #app.timeline-enabled #content {
      grid-template-rows: auto 260px;
    }

    #app.timeline-enabled #monitor {
      max-height: 220px;
    }

    #app.timeline-enabled #monitor {
      grid-column: 3;
      grid-row: 1;
      align-self: start;
    }

    #app.timeline-enabled #takes {
      grid-column: 2;
      grid-row: 1;
    }

    #app.timeline-enabled #controls {
      overflow: auto;
    }

    #timelinePanel {
      display: none;
      grid-column: 1 / -1;
      min-height: 220px;
    }

    #app.timeline-enabled #timelinePanel {
      display: flex;
    }

    .panel {
      background: linear-gradient(180deg, #1a222b, #182029);
      border: 1px solid var(--panel-edge);
      border-radius: 12px;
      box-shadow: 0 8px 20px var(--shadow);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header {
      padding: 10px 12px;
      border-bottom: 1px solid #25303b;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .panel-header h3 {
      margin: 0;
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .panel-body {
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      font-size: 11px;
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    button, select, input[type="text"], input[type="number"] {
      background: var(--panel-hi);
      color: var(--text);
      border: 1px solid var(--panel-edge);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 12px;
      outline: none;
    }

    code {
      background: #0f141a;
      border: 1px solid #25303b;
      border-radius: 6px;
      padding: 6px 8px;
      font-family: "Lucida Console", "Courier New", monospace;
      font-size: 11px;
      color: #d9e5ef;
    }

    .help {
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
    }

    .folder-status {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 700;
      background: #331618;
      color: #ff8a8a;
      border: 1px solid #4a1c22;
    }

    .folder-status.ready {
      background: #10351f;
      color: #6ef19b;
      border-color: #1f5a36;
    }

    button {
      cursor: pointer;
      transition: transform 0.12s ease, background 0.2s ease, border-color 0.2s ease;
    }

    button:hover {
      background: #2a3541;
      border-color: #3a4756;
    }

    button:active {
      transform: translateY(1px);
    }

    button.primary {
      background: var(--accent-2);
      border-color: rgba(58, 162, 255, 0.6);
      color: #081b2d;
      font-weight: 700;
    }

    button.danger {
      background: var(--danger);
      border-color: #ff7a7a;
      color: #2b0b0b;
      font-weight: 700;
    }

    button.ghost {
      background: transparent;
      border: 1px dashed var(--panel-edge);
      color: var(--muted);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    #monitorFrame {
      position: relative;
      margin: 10px;
      border-radius: 12px;
      background: #06080b;
      flex: 1;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #app.timeline-enabled #monitorFrame {
      margin: 6px;
    }

    #liveVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: none;
    }

    #monitorPlaceholder {
      color: var(--muted);
      font-size: 13px;
    }

    #takesList {
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: auto;
      flex: 1;
    }

    #app.timeline-enabled #takesList {
      display: none;
    }

    #stageView {
      display: none;
      flex: 1;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      overflow: auto;
    }

    #app.timeline-enabled #stageView {
      display: flex;
    }

    .stage-current {
      font-size: 12px;
      font-weight: 700;
    }

    .stage-item {
      font-size: 11px;
      color: var(--muted);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #1f2a35;
      background: #0f141a;
    }

    .stage-item.top {
      color: #d9e5ef;
      border-color: #2f4a60;
      background: #16202a;
    }

    .take-item {
      background: #121820;
      border: 1px solid transparent;
      border-radius: 8px;
      padding: 6px;
      display: grid;
      grid-template-columns: 54px 1fr;
      gap: 8px;
      align-items: center;
    }

    .take-title {
      font-size: 12px;
      font-weight: 700;
    }

    .take-meta {
      font-size: 11px;
      color: var(--muted);
    }

    .take-thumb {
      width: 54px;
      height: 36px;
      border-radius: 6px;
      background: #0a0e13;
      border: 1px solid #1f2a35;
      background-size: cover;
      background-position: center;
    }

    .take-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .take-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .take-delete {
      font-size: 11px;
      padding: 4px 6px;
    }

    #timelineBody {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    #timelineViewport {
      position: relative;
      flex: 1;
      overflow: auto;
      background: #0a0e13;
      border-top: 1px solid #1f2a35;
    }

    #timelineViewport::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    #timelineViewport::-webkit-scrollbar-track {
      background: #0b1016;
    }

    #timelineViewport::-webkit-scrollbar-thumb {
      background: #1f2a35;
      border-radius: 8px;
      border: 1px solid #0b1016;
    }

    #timelineViewport::-webkit-scrollbar-thumb:hover {
      background: #2b3847;
    }

    #monitorProjectSlot {
      padding: 0 10px 10px;
    }

    #timelineCanvas {
      position: relative;
      min-height: 100%;
      background-color: #0b1016;
    }

    #timelineRuler {
      position: relative;
      height: 24px;
      border-bottom: 1px solid #1f2a35;
      background: rgba(12, 16, 22, 0.9);
      z-index: 2;
    }

    .ruler-label {
      position: absolute;
      top: 4px;
      font-size: 10px;
      color: var(--muted);
      transform: translateX(-50%);
      white-space: nowrap;
    }

    #timelineLanes {
      position: relative;
    }

    .timeline-lane {
      position: relative;
      height: 54px;
      border-bottom: 1px solid #1b2430;
    }

    .timeline-clip {
      position: absolute;
      top: 7px;
      height: 40px;
      background: #2a3a4b;
      border: 1px solid #3e566f;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      color: #d9e5ef;
      cursor: grab;
      box-sizing: border-box;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .timeline-clip.selected {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 1px rgba(46, 196, 182, 0.35);
    }

    .clip-handle {
      position: absolute;
      top: 0;
      width: 6px;
      height: 100%;
      background: rgba(79, 104, 131, 0.9);
      cursor: ew-resize;
    }

    .clip-handle.left {
      left: 0;
      border-top-left-radius: 6px;
      border-bottom-left-radius: 6px;
    }

    .clip-handle.right {
      right: 0;
      border-top-right-radius: 6px;
      border-bottom-right-radius: 6px;
    }

    #timelinePlayhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(255, 77, 77, 0.8);
      z-index: 5;
      pointer-events: none;
    }

    #experimentalBar {
      margin-top: 10px;
      display: flex;
      justify-content: center;
    }

    @media (max-width: 1100px) {
      #content {
        grid-template-columns: 1fr;
      }

      #topbar {
        grid-template-columns: 1fr;
        justify-items: start;
      }

      #timeRow,
      #statusRow {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header id="topbar">
      <div id="brand">
        <h1>CamOrder Recorder</h1>
        <span>MIDI clock synced video capture for DAWs</span>
      </div>
      <div id="statusRow">
        <span id="midiStatus" class="pill">MIDI Off</span>
        <span id="recordStatus" class="pill">Idle</span>
        <span id="cameraStatus" class="pill">Camera Off</span>
        <span id="folderPill" class="pill">Folder Missing</span>
      </div>
      <div id="timeRow">
        <span id="timeDisplay">00:00:00:00</span>
        <span id="bpmDisplay">120.0 BPM</span>
      </div>
    </header>

    <section id="content">
      <aside id="controls" class="panel">
        <div class="panel-header"><h3>Sync</h3></div>
        <div class="panel-body">
          <div class="field">
            <label>MIDI Input (Clock)</label>
            <select id="midiInputSelect"></select>
          </div>
          <div class="row">
            <button id="midiConnectBtn" class="ghost">Enable MIDI</button>
            <button id="armBtn" class="danger">Arm Recorder</button>
          </div>
          <div class="row">
            <label>FPS
              <select id="fpsSelect">
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="30" selected>30</option>
                <option value="60">60</option>
              </select>
            </label>
          </div>
        </div>

        <div class="panel-header"><h3>Camera</h3></div>
        <div class="panel-body">
          <div class="field">
            <label>Source</label>
            <select id="cameraSelect"></select>
          </div>
          <div class="field">
            <label>Resolution</label>
            <select id="resolutionSelect"></select>
          </div>
          <div class="row">
            <button id="enableCameraBtn" class="ghost">Enable Camera</button>
            <button id="refreshDevices" class="ghost">Refresh</button>
          </div>
        </div>

        <div id="projectSlot">
          <div id="projectBlock">
            <div class="panel-header"><h3>Project</h3></div>
            <div class="panel-body">
              <div class="row">
                <button id="chooseFolderBtn" class="ghost">Choose Project Folder</button>
                <span id="folderStatus" class="folder-status">X</span>
              </div>
              <div class="row">
                <button id="exportPackageBtn" class="primary">Export Resolve Package</button>
              </div>
              <div class="field">
                <label>Convert Command</label>
                <div class="row">
                  <code id="convertCmdInline">sh convert-to-mov.sh</code>
                  <button id="copyConvertBtn" class="ghost">Copy</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </aside>

      <section id="monitor" class="panel">
        <div class="panel-header"><h3>Live Preview</h3></div>
        <div id="monitorFrame">
          <video id="liveVideo" muted playsinline autoplay></video>
          <div id="monitorPlaceholder">Enable camera to preview the feed.</div>
        </div>
        <div id="monitorProjectSlot"></div>
      </section>

      <aside id="takes" class="panel">
        <div class="panel-header">
          <h3 id="takesHeader">Takes</h3>
        </div>
        <div id="takesList"></div>
        <div id="stageView">
          <div id="stageCurrent" class="stage-current">Stage: None</div>
          <div id="stageList"></div>
        </div>
      </aside>

      <section id="timelinePanel" class="panel">
        <div class="panel-header">
          <h3>Experimental Timeline</h3>
          <div class="row">
            <label>Record Lane
              <select id="laneSelect"></select>
            </label>
            <button id="addLaneBtn" class="ghost">Add Lane</button>
            <button id="deletePlacementBtn" class="ghost">Delete Clip</button>
          </div>
        </div>
        <div id="timelineBody">
          <div id="timelineViewport">
            <div id="timelineCanvas">
              <div id="timelineRuler"></div>
              <div id="timelineLanes"></div>
              <div id="timelinePlayhead"></div>
            </div>
          </div>
        </div>
      </section>
    </section>

    <div id="experimentalBar">
      <button id="toggleTimelineBtn" class="ghost">Experimental Video Timeline</button>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      const pad = (num, size = 2) => String(num).padStart(size, '0');

      function secondsToSMPTE(seconds, fps) {
        const safe = Math.max(0, seconds || 0);
        const totalFrames = Math.floor(safe * fps + 1e-6);
        const frames = totalFrames % fps;
        const totalSeconds = Math.floor(totalFrames / fps);
        const secs = totalSeconds % 60;
        const mins = Math.floor(totalSeconds / 60) % 60;
        const hours = Math.floor(totalSeconds / 3600);
        return `${pad(hours)}:${pad(mins)}:${pad(secs)}:${pad(frames)}`;
      }

      function secondsToFcpDuration(seconds, fps) {
        const frames = Math.max(0, Math.round(seconds * fps));
        if (frames === 0) return '0s';
        return `${frames}/${fps}s`;
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function snapSeconds(seconds, fps) {
        const frame = 1 / fps;
        return Math.round(seconds / frame) * frame;
      }

      const state = {
        settings: {
          fps: 30,
        },
        export: {
          mediaBasePath: '',
          statusMessage: '',
        },
        midi: {
          access: null,
          input: null,
          connected: false,
          clock: {
            lastTick: 0,
            bpm: 120,
            playing: false,
            songPositionSeconds: 0,
          },
        },
        camera: {
          stream: null,
          source: null,
          status: 'off',
        },
        recording: {
          active: false,
          pending: false,
          clipId: null,
          startPlayhead: 0,
          recorder: null,
          chunks: [],
        },
        timeline: {
          enabled: false,
          lanes: 3,
          selectedLane: 0,
          pxPerBeat: 84,
          subdivisions: 4,
          beatsPerBar: 4,
          selectionId: null,
          drag: null,
          lastGridBpm: 0,
        },
        clips: [],
        placements: [],
        mediaCache: new Map(),
        playheadSeconds: 0,
        armed: true,
        projectHandle: null,
        dirty: false,
      };

      const dom = {};

      function cacheDom() {
        dom.midiStatus = document.getElementById('midiStatus');
        dom.recordStatus = document.getElementById('recordStatus');
        dom.cameraStatus = document.getElementById('cameraStatus');
        dom.timeDisplay = document.getElementById('timeDisplay');
        dom.bpmDisplay = document.getElementById('bpmDisplay');
        dom.midiInputSelect = document.getElementById('midiInputSelect');
        dom.midiConnectBtn = document.getElementById('midiConnectBtn');
        dom.armBtn = document.getElementById('armBtn');
        dom.fpsSelect = document.getElementById('fpsSelect');
        dom.folderPill = document.getElementById('folderPill');
        dom.cameraSelect = document.getElementById('cameraSelect');
        dom.resolutionSelect = document.getElementById('resolutionSelect');
        dom.enableCameraBtn = document.getElementById('enableCameraBtn');
        dom.refreshDevices = document.getElementById('refreshDevices');
        dom.chooseFolderBtn = document.getElementById('chooseFolderBtn');
        dom.exportPackageBtn = document.getElementById('exportPackageBtn');
        dom.convertCmdInline = document.getElementById('convertCmdInline');
        dom.copyConvertBtn = document.getElementById('copyConvertBtn');
        dom.folderStatus = document.getElementById('folderStatus');
        dom.liveVideo = document.getElementById('liveVideo');
        dom.monitorPlaceholder = document.getElementById('monitorPlaceholder');
        dom.projectBlock = document.getElementById('projectBlock');
        dom.projectSlot = document.getElementById('projectSlot');
        dom.monitorProjectSlot = document.getElementById('monitorProjectSlot');
        dom.takesList = document.getElementById('takesList');
        dom.takesHeader = document.getElementById('takesHeader');
        dom.stageView = document.getElementById('stageView');
        dom.stageCurrent = document.getElementById('stageCurrent');
        dom.stageList = document.getElementById('stageList');
        dom.timelinePanel = document.getElementById('timelinePanel');
        dom.timelineViewport = document.getElementById('timelineViewport');
        dom.timelineCanvas = document.getElementById('timelineCanvas');
        dom.timelineRuler = document.getElementById('timelineRuler');
        dom.timelineLanes = document.getElementById('timelineLanes');
        dom.timelinePlayhead = document.getElementById('timelinePlayhead');
        dom.laneSelect = document.getElementById('laneSelect');
        dom.addLaneBtn = document.getElementById('addLaneBtn');
        dom.deletePlacementBtn = document.getElementById('deletePlacementBtn');
        dom.toggleTimelineBtn = document.getElementById('toggleTimelineBtn');
      }

      function markDirty() {
        state.dirty = true;
      }

      function makeId(prefix) {
        return `${prefix}-${Math.random().toString(36).slice(2, 9)}`;
      }

      function setPlayhead(seconds) {
        const snapped = Math.max(0, snapSeconds(seconds, state.settings.fps));
        state.playheadSeconds = snapped;
        dom.timeDisplay.textContent = secondsToSMPTE(snapped, state.settings.fps);
        updateTimelinePlayhead();
        renderStageView();
      }

      function setMidiStatus(status, label = '') {
        let text = label || 'MIDI Off';
        let cls = 'pill';
        if (status === 'ready') {
          text = label || 'MIDI Ready';
          cls = 'pill live';
        } else if (status === 'connected') {
          text = label || 'MIDI Connected';
          cls = 'pill live';
        } else if (status === 'warn') {
          text = label || 'MIDI Warning';
          cls = 'pill warn';
        }
        dom.midiStatus.textContent = text;
        dom.midiStatus.className = cls;
      }

      function setRecordStatus(status) {
        if (status === 'recording') {
          dom.recordStatus.textContent = 'Recording';
          dom.recordStatus.className = 'pill recording';
        } else if (status === 'armed') {
          dom.recordStatus.textContent = 'Armed';
          dom.recordStatus.className = 'pill live';
        } else {
          dom.recordStatus.textContent = 'Idle';
          dom.recordStatus.className = 'pill';
        }
      }

      function setCameraStatus(status) {
        state.camera.status = status;
        if (status === 'ready') {
          dom.cameraStatus.textContent = 'Camera Ready';
          dom.cameraStatus.className = 'pill live';
        } else if (status === 'blocked') {
          dom.cameraStatus.textContent = 'Camera Blocked';
          dom.cameraStatus.className = 'pill warn';
        } else if (status === 'busy') {
          dom.cameraStatus.textContent = 'Camera Busy';
          dom.cameraStatus.className = 'pill warn';
        } else if (status === 'live') {
          dom.cameraStatus.textContent = 'Camera Live';
          dom.cameraStatus.className = 'pill recording';
        } else {
          dom.cameraStatus.textContent = 'Camera Off';
          dom.cameraStatus.className = 'pill';
        }
      }

      function updateExportNotes() {
        if (!dom.exportNotes) return;
        dom.exportNotes.textContent = state.export.statusMessage || '';
      }

      function setExportStatus(message) {
        state.export.statusMessage = message || '';
        updateExportNotes();
      }

      function updateFolderStatus() {
        if (!dom.folderStatus) return;
        if (state.projectHandle) {
          dom.folderStatus.textContent = 'OK';
          dom.folderStatus.classList.add('ready');
          if (dom.folderPill) {
            dom.folderPill.textContent = 'Folder Ready';
            dom.folderPill.className = 'pill live';
          }
        } else {
          dom.folderStatus.textContent = 'X';
          dom.folderStatus.classList.remove('ready');
          if (dom.folderPill) {
            dom.folderPill.textContent = 'Folder Missing';
            dom.folderPill.className = 'pill warn';
          }
        }
      }

      function moveProjectBlock() {
        if (!dom.projectBlock || !dom.projectSlot || !dom.monitorProjectSlot) return;
        const target = state.timeline.enabled ? dom.monitorProjectSlot : dom.projectSlot;
        if (dom.projectBlock.parentElement !== target) {
          target.appendChild(dom.projectBlock);
        }
      }

      function getActivePlacementsAtPlayhead() {
        return state.placements.filter((placement) => {
          const start = placement.timelineStartSeconds;
          const end = placement.timelineStartSeconds + placement.durationSeconds;
          return state.playheadSeconds >= start && state.playheadSeconds <= end;
        });
      }

      function renderStageView() {
        if (!dom.stageCurrent || !dom.stageList) return;
        if (!state.timeline.enabled) return;
        const active = getActivePlacementsAtPlayhead();
        const enriched = active.map((placement) => {
          const clip = getClipById(placement.clipId);
          return {
            placement,
            clip,
            lane: typeof placement.lane === 'number' ? placement.lane : 0,
          };
        });
        enriched.sort((a, b) => a.lane - b.lane);
        const top = enriched.length ? enriched[enriched.length - 1] : null;
        dom.stageCurrent.textContent = top && top.clip
          ? `Stage: ${top.clip.name}`
          : 'Stage: None';
        dom.stageList.innerHTML = '';
        if (!enriched.length) {
          const empty = document.createElement('div');
          empty.className = 'stage-item';
          empty.textContent = 'No clips at playhead.';
          dom.stageList.appendChild(empty);
          return;
        }
        enriched.forEach((item) => {
          const row = document.createElement('div');
          row.className = 'stage-item';
          if (top && item === top) row.classList.add('top');
          const name = item.clip ? item.clip.name : item.placement.clipId;
          row.textContent = `Lane ${item.lane + 1}: ${name}`;
          dom.stageList.appendChild(row);
        });
      }

      function getBpm() {
        return Math.max(20, state.midi.clock.bpm || 120);
      }

      function getSecondsPerBeat() {
        return 60 / getBpm();
      }

      function snapToBeatGrid(seconds) {
        const grid = getSecondsPerBeat() / state.timeline.subdivisions;
        if (!grid) return seconds;
        return Math.max(0, Math.round(seconds / grid) * grid);
      }

      function timeToPx(seconds) {
        return (seconds / getSecondsPerBeat()) * state.timeline.pxPerBeat;
      }

      function pxToTime(pixels) {
        return (pixels / state.timeline.pxPerBeat) * getSecondsPerBeat();
      }

      function updateLaneSelect() {
        if (!dom.laneSelect) return;
        if (state.timeline.selectedLane >= state.timeline.lanes) {
          state.timeline.selectedLane = Math.max(0, state.timeline.lanes - 1);
        }
        dom.laneSelect.innerHTML = '';
        for (let i = 0; i < state.timeline.lanes; i += 1) {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `Lane ${i + 1}`;
          dom.laneSelect.appendChild(opt);
        }
        dom.laneSelect.value = String(state.timeline.selectedLane);
      }

      function getTimelineSpanSeconds() {
        const baseline = Math.max(getTimelineDurationSeconds(), state.playheadSeconds);
        const beatsAhead = state.timeline.beatsPerBar * 4;
        return Math.max(baseline, state.playheadSeconds + getSecondsPerBeat() * beatsAhead);
      }

      function updateTimelineGrid(widthPx) {
        if (!dom.timelineCanvas) return;
        const beatPx = state.timeline.pxPerBeat;
        const subPx = beatPx / state.timeline.subdivisions;
        const barPx = beatPx * state.timeline.beatsPerBar;
        dom.timelineCanvas.style.backgroundImage = [
          'linear-gradient(to right, rgba(42, 53, 65, 0.55) 1px, transparent 1px)',
          'linear-gradient(to right, rgba(28, 37, 47, 0.5) 1px, transparent 1px)',
          'linear-gradient(to right, rgba(22, 28, 36, 0.35) 1px, transparent 1px)',
        ].join(', ');
        dom.timelineCanvas.style.backgroundSize = `${barPx}px 100%, ${beatPx}px 100%, ${subPx}px 100%`;
        dom.timelineCanvas.style.width = `${Math.max(widthPx, dom.timelineViewport.clientWidth)}px`;
      }

      function renderTimelineRuler(spanSeconds) {
        if (!dom.timelineRuler) return;
        dom.timelineRuler.innerHTML = '';
        const beats = Math.ceil(spanSeconds / getSecondsPerBeat());
        const totalBars = Math.max(1, Math.ceil(beats / state.timeline.beatsPerBar));
        for (let bar = 0; bar <= totalBars; bar += 1) {
          const beat = bar * state.timeline.beatsPerBar;
          const seconds = beat * getSecondsPerBeat();
          const left = timeToPx(seconds);
          const label = document.createElement('div');
          label.className = 'ruler-label';
          label.style.left = `${left}px`;
          label.textContent = `Bar ${bar + 1}`;
          dom.timelineRuler.appendChild(label);
        }
      }

      function renderTimeline() {
        if (!state.timeline.enabled) return;
        if (!dom.timelineCanvas || !dom.timelineLanes) return;
        updateLaneSelect();
        const spanSeconds = getTimelineSpanSeconds();
        const widthPx = timeToPx(spanSeconds) + 200;
        updateTimelineGrid(widthPx);
        dom.timelineRuler.style.width = dom.timelineCanvas.style.width;
        dom.timelineLanes.style.width = dom.timelineCanvas.style.width;
        renderTimelineRuler(spanSeconds);

        dom.timelineLanes.innerHTML = '';
        for (let lane = 0; lane < state.timeline.lanes; lane += 1) {
          const row = document.createElement('div');
          row.className = 'timeline-lane';
          row.dataset.lane = String(lane);
          dom.timelineLanes.appendChild(row);
        }

        const placements = state.placements.filter((placement) => placement.durationSeconds > 0.01);
        placements.forEach((placement) => {
          if (typeof placement.lane !== 'number') placement.lane = 0;
          const laneIndex = Math.max(0, Math.min(state.timeline.lanes - 1, placement.lane));
          const row = dom.timelineLanes.querySelector(`[data-lane="${laneIndex}"]`);
          if (!row) return;
          const clip = getClipById(placement.clipId);
          const clipEl = document.createElement('div');
          clipEl.className = 'timeline-clip';
          clipEl.dataset.placementId = placement.id;
          const clipStart = placement.timelineStartSeconds;
          const duration = Math.max(0.01, placement.durationSeconds);
          clipEl.style.left = `${timeToPx(clipStart)}px`;
          clipEl.style.width = `${Math.max(12, timeToPx(duration))}px`;
          clipEl.textContent = clip ? clip.name : placement.clipId;
          if (state.timeline.selectionId === placement.id) {
            clipEl.classList.add('selected');
          }
          const leftHandle = document.createElement('div');
          leftHandle.className = 'clip-handle left';
          const rightHandle = document.createElement('div');
          rightHandle.className = 'clip-handle right';
          clipEl.appendChild(leftHandle);
          clipEl.appendChild(rightHandle);
          row.appendChild(clipEl);
        });

        updateTimelinePlayhead();
        renderStageView();
      }

      function updateTimelinePlayhead() {
        if (!state.timeline.enabled || !dom.timelinePlayhead) return;
        const left = timeToPx(state.playheadSeconds);
        dom.timelinePlayhead.style.left = `${left}px`;
      }

      function updateTimelineRecordingClip() {
        if (!state.timeline.enabled || !state.recording.active) return;
        const placement = state.placements.find((item) => item.clipId === state.recording.clipId);
        if (!placement) return;
        const el = dom.timelineCanvas
          ? dom.timelineCanvas.querySelector(`[data-placement-id="${placement.id}"]`)
          : null;
        if (!el) {
          renderTimeline();
          return;
        }
        el.style.left = `${timeToPx(placement.timelineStartSeconds)}px`;
        el.style.width = `${Math.max(12, timeToPx(placement.durationSeconds))}px`;
      }

      function selectPlacement(placementId) {
        state.timeline.selectionId = placementId;
        renderTimeline();
      }

      function deleteSelectedPlacement() {
        const selection = state.timeline.selectionId;
        if (!selection) return;
        state.placements = state.placements.filter((placement) => placement.id !== selection);
        state.timeline.selectionId = null;
        markDirty();
        renderTimeline();
      }

      function handleTimelineMouseDown(event) {
        if (!state.timeline.enabled) return;
        if (!dom.timelineCanvas || !dom.timelineViewport) return;
        const clipEl = event.target.closest('.timeline-clip');
        if (clipEl) {
          const placementId = clipEl.dataset.placementId;
          const placement = getPlacementById(placementId);
          if (!placement) return;
          selectPlacement(placementId);
          const rect = clipEl.getBoundingClientRect();
          const handle = event.target.classList.contains('clip-handle')
            ? (event.target.classList.contains('left') ? 'trim-left' : 'trim-right')
            : 'move';
          state.timeline.drag = {
            type: handle,
            placementId,
            startX: event.clientX,
            startY: event.clientY,
            startStart: placement.timelineStartSeconds,
            startDuration: placement.durationSeconds,
            startClipIn: placement.clipInSeconds,
            lane: placement.lane || 0,
            rectTop: rect.top,
          };
          event.preventDefault();
          return;
        }

        const canvasRect = dom.timelineCanvas.getBoundingClientRect();
        const x = event.clientX - canvasRect.left + dom.timelineViewport.scrollLeft;
        const seconds = snapToBeatGrid(pxToTime(x));
        setPlayhead(seconds);
        if (state.timeline.selectionId) {
          state.timeline.selectionId = null;
          renderTimeline();
        }
      }

      function handleTimelineMouseMove(event) {
        if (!state.timeline.drag) return;
        if (!dom.timelineLanes || !dom.timelineViewport) return;
        const drag = state.timeline.drag;
        const placement = getPlacementById(drag.placementId);
        if (!placement) return;
        const deltaPx = event.clientX - drag.startX;
        const deltaSeconds = pxToTime(deltaPx);
        if (drag.type === 'move') {
          const newStart = snapToBeatGrid(drag.startStart + deltaSeconds);
          placement.timelineStartSeconds = Math.max(0, newStart);
          const lanesRect = dom.timelineLanes.getBoundingClientRect();
          const y = event.clientY - lanesRect.top + dom.timelineViewport.scrollTop;
          const laneIndex = Math.max(0, Math.min(state.timeline.lanes - 1, Math.floor(y / 54)));
          placement.lane = laneIndex;
        } else if (drag.type === 'trim-left') {
          const clip = getClipById(placement.clipId);
          if (!clip) return;
          const newStart = snapToBeatGrid(drag.startStart + deltaSeconds);
          const maxStart = drag.startStart + drag.startDuration - 0.1;
          const clampedStart = Math.min(maxStart, Math.max(0, newStart));
          const delta = clampedStart - drag.startStart;
          const newClipIn = Math.max(0, drag.startClipIn + delta);
          const maxClipIn = Math.max(0, clip.durationSeconds - 0.1);
          placement.timelineStartSeconds = clampedStart;
          placement.clipInSeconds = Math.min(maxClipIn, newClipIn);
          placement.durationSeconds = Math.max(0.1, drag.startDuration - delta);
        } else if (drag.type === 'trim-right') {
          const clip = getClipById(placement.clipId);
          if (!clip) return;
          const newDur = snapToBeatGrid(drag.startDuration + deltaSeconds);
          const maxDur = Math.max(0.1, clip.durationSeconds - placement.clipInSeconds);
          placement.durationSeconds = Math.min(maxDur, Math.max(0.1, newDur));
        }
        placement.clipOutSeconds = placement.clipInSeconds + placement.durationSeconds;
        markDirty();
        renderTimeline();
      }

      function handleTimelineMouseUp() {
        if (!state.timeline.drag) return;
        state.timeline.drag = null;
      }

      async function copyTextToClipboard(text) {
        if (!text) return false;
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (error) {
          const temp = document.createElement('textarea');
          temp.value = text;
          temp.style.position = 'fixed';
          temp.style.opacity = '0';
          document.body.appendChild(temp);
          temp.focus();
          temp.select();
          const ok = document.execCommand('copy');
          temp.remove();
          return ok;
        }
      }

      function getConvertCommand() {
        return 'sh convert-to-mov.sh';
      }

      function updateBpmDisplay() {
        dom.bpmDisplay.textContent = `${state.midi.clock.bpm.toFixed(1)} BPM`;
        if (!state.timeline.enabled) return;
        const bpm = getBpm();
        if (Math.abs(bpm - state.timeline.lastGridBpm) >= 0.2) {
          state.timeline.lastGridBpm = bpm;
          renderTimeline();
        }
      }

      function populateResolutionOptions() {
        const presets = [
          { label: '640x480', width: 640, height: 480 },
          { label: '1280x720', width: 1280, height: 720 },
          { label: '1920x1080', width: 1920, height: 1080 },
          { label: '2560x1440', width: 2560, height: 1440 },
        ];
        dom.resolutionSelect.innerHTML = '';
        presets.forEach((preset) => {
          const option = document.createElement('option');
          option.value = `${preset.width}x${preset.height}`;
          option.textContent = preset.label;
          dom.resolutionSelect.appendChild(option);
        });
        dom.resolutionSelect.value = '1280x720';
      }

      function updateCameraSourceUI() {
        const isScreen = dom.cameraSelect.value === 'screen';
        dom.resolutionSelect.disabled = isScreen;
      }

      function clearCameraStream(stopTracks = true) {
        if (state.camera.stream && stopTracks) {
          state.camera.stream.getTracks().forEach((track) => track.stop());
        }
        state.camera.stream = null;
        state.camera.source = null;
        dom.liveVideo.srcObject = null;
        dom.liveVideo.style.display = 'none';
        dom.monitorPlaceholder.style.display = 'block';
      }

      async function getCameraStream() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          alert('Camera capture is not supported in this browser.');
          setCameraStatus('blocked');
          return null;
        }
        try {
          const source = dom.cameraSelect.value;
          if (state.camera.stream && state.camera.source === source && state.camera.stream.active) {
            dom.liveVideo.srcObject = state.camera.stream;
            dom.liveVideo.style.display = 'block';
            dom.monitorPlaceholder.style.display = 'none';
            dom.liveVideo.play().catch(() => {});
            setCameraStatus('ready');
            return state.camera.stream;
          }
          if (state.camera.stream) clearCameraStream(true);
          setCameraStatus('busy');
          let stream;
          if (source === 'screen') {
            if (!navigator.mediaDevices.getDisplayMedia) {
              alert('Screen capture is not supported in this browser.');
              setCameraStatus('blocked');
              return null;
            }
            stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
          } else {
            const [width, height] = dom.resolutionSelect.value.split('x').map(Number);
            const deviceId = source || undefined;
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                deviceId: deviceId ? { exact: deviceId } : undefined,
                width: { ideal: width },
                height: { ideal: height },
              },
              audio: false,
            });
          }
          state.camera.stream = stream;
          state.camera.source = source;
          stream.getTracks().forEach((track) => {
            track.onended = () => {
              if (state.camera.stream === stream) {
                clearCameraStream(false);
                setCameraStatus('off');
              }
            };
          });
          dom.liveVideo.srcObject = stream;
          dom.liveVideo.style.display = 'block';
          dom.monitorPlaceholder.style.display = 'none';
          dom.liveVideo.play().catch(() => {});
          setCameraStatus('ready');
          return stream;
        } catch (error) {
          alert(`Unable to access camera: ${error.message}`);
          setCameraStatus('blocked');
          return null;
        }
      }

      async function warmUpCamera(allowScreen = false) {
        if (dom.cameraSelect.value === 'screen' && !allowScreen) {
          setCameraStatus('off');
          return;
        }
        if (state.camera.stream && state.camera.stream.active) {
          setCameraStatus('ready');
          return;
        }
        await getCameraStream();
      }

      function refreshDevices() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          dom.cameraSelect.innerHTML = '<option value="">No devices</option>';
          return;
        }
        navigator.mediaDevices.enumerateDevices().then((devices) => {
          const cameras = devices.filter((device) => device.kind === 'videoinput');
          dom.cameraSelect.innerHTML = '';
          const screenOption = document.createElement('option');
          screenOption.value = 'screen';
          screenOption.textContent = 'Screen / Window Capture';
          dom.cameraSelect.appendChild(screenOption);
          cameras.forEach((camera) => {
            const option = document.createElement('option');
            option.value = camera.deviceId;
            option.textContent = camera.label || `Camera ${dom.cameraSelect.length}`;
            dom.cameraSelect.appendChild(option);
          });
          if (!cameras.length) dom.cameraSelect.value = 'screen';
          updateCameraSourceUI();
        }).catch(() => {
          dom.cameraSelect.innerHTML = '<option value="">Camera list blocked</option>';
        });
      }

      function getSupportedMimeType() {
        const types = [
          'video/webm;codecs=vp9',
          'video/webm;codecs=vp8',
          'video/webm',
        ];
        for (const type of types) {
          if (MediaRecorder.isTypeSupported(type)) return type;
        }
        return '';
      }

      async function ensurePermission(handle) {
        if (!handle) return false;
        if (await handle.queryPermission({ mode: 'readwrite' }) === 'granted') return true;
        return (await handle.requestPermission({ mode: 'readwrite' })) === 'granted';
      }

      async function chooseProjectFolder() {
        if (!window.showDirectoryPicker) {
          alert('File System Access API not available.');
          return;
        }
        state.projectHandle = await window.showDirectoryPicker();
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) alert('Write permission denied for the selected folder.');
        if (!ok) return;
        setExportStatus('Project folder selected.');
        updateFolderStatus();
      }

      async function saveRecordedClipToProject(clip, blob) {
        if (!state.projectHandle) return;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return;
        const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: true });
        const filename = clip.filename || `${clip.id}.webm`;
        clip.filename = filename;
        const handle = await mediaDir.getFileHandle(filename, { create: true });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
      }

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      }

      function sanitizeReelName(name) {
        const base = (name || 'REEL').replace(/\.[^/.]+$/, '');
        const clean = base.replace(/[^a-z0-9]/gi, '_').toUpperCase();
        return clean.slice(0, 8) || 'REEL001';
      }

      function resolveClipFilename(clip, preferMov = false) {
        const raw = clip?.filename || clip?.name || clip?.id || 'clip';
        if (!preferMov) return raw;
        if (clip && clip.source !== 'recorded') return raw;
        const base = raw.replace(/\.[^/.]+$/, '');
        return `${base}.mov`;
      }

      function sanitizeBasePath(path) {
        if (!path) return '';
        let value = path.trim();
        value = value.replace(/^['"]+|['"]+$/g, '');
        if (!value) return '';
        value = value.replace(/\\/g, '/');
        return value.replace(/\/+$/, '');
      }

      function makeFileUrl(path, filename) {
        const base = sanitizeBasePath(path);
        if (!base) return `media/${filename}`;
        let normalized = base;
        let prefix = 'file://';
        if (normalized.startsWith('file://')) {
          normalized = normalized.slice('file://'.length);
          if (normalized.startsWith('localhost/')) {
            normalized = normalized.slice('localhost/'.length);
            prefix = 'file://localhost';
          }
        }
        normalized = normalized.replace(/^\/+/, '/');
        const combined = `${normalized}/${filename}`;
        const encoded = combined.split('/').map(encodeURIComponent).join('/');
        return `${prefix}${encoded}`;
      }

      function getPlacementsForExport() {
        const fps = state.settings.fps;
        const frame = 1 / fps;
        const seen = new Set();
        return state.placements
          .map((placement) => ({
            ...placement,
            end: placement.timelineStartSeconds + placement.durationSeconds,
          }))
          .filter((placement) => placement.durationSeconds > frame)
          .filter((placement) => {
            const key = [
              placement.clipId,
              placement.timelineStartSeconds.toFixed(3),
              placement.durationSeconds.toFixed(3),
              placement.clipInSeconds.toFixed(3),
            ].join('|');
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });
      }

      function buildStackedFcpXml(preferMp4 = true) {
        const fps = state.settings.fps;
        const placements = getPlacementsForExport().sort((a, b) => a.timelineStartSeconds - b.timelineStartSeconds);
        const frame = 1 / fps;
        const lanes = [];
        const items = placements.map((placement) => {
          const start = placement.timelineStartSeconds;
          const end = placement.end;
          let lane = 0;
          for (; lane < lanes.length; lane += 1) {
            if (start >= lanes[lane] - frame) break;
          }
          if (lane === lanes.length) lanes.push(end);
          else lanes[lane] = Math.max(lanes[lane], end);
          return { ...placement, lane };
        });

        const usedClipIds = new Set(items.map((item) => item.clipId));
        const formatId = 'r1';
        const formatWidth = 1920;
        const formatHeight = 1080;
        const frameDuration = `1/${fps}s`;
        const totalDuration = secondsToFcpDuration(getTimelineDurationSeconds(), fps);

        const assetLines = [];
        Array.from(usedClipIds).forEach((clipId, index) => {
          const clip = getClipById(clipId);
          if (!clip) return;
          const assetId = `r${index + 2}`;
          const filename = resolveClipFilename(clip, preferMp4);
          const src = makeFileUrl(state.export.mediaBasePath, filename);
          const duration = secondsToFcpDuration(Math.max(clip.durationSeconds, 0), fps);
          const safeName = (clip.name || clip.id).replace(/\"/g, '');
          assetLines.push(
            `    <asset id=\"${assetId}\" name=\"${safeName}\" src=\"${src}\" start=\"0s\" duration=\"${duration}\" hasVideo=\"1\" hasAudio=\"0\" format=\"${formatId}\"/>`
          );
          clip.__assetId = assetId;
        });

        const spineLines = [];
        items.forEach((item) => {
          const clip = getClipById(item.clipId);
          if (!clip) return;
          const assetId = clip.__assetId;
          const clipName = (clip.name || clip.id).replace(/\"/g, '');
          const clipIn = snapSeconds(item.clipInSeconds, fps);
          const duration = snapSeconds(item.durationSeconds, fps);
          const offset = secondsToFcpDuration(item.timelineStartSeconds, fps);
          const start = secondsToFcpDuration(clipIn, fps);
          const dur = secondsToFcpDuration(duration, fps);
          const laneAttr = item.lane > 0 ? ` lane=\"${item.lane}\"` : '';
          spineLines.push(
            `          <asset-clip name=\"${clipName}\" ref=\"${assetId}\" offset=\"${offset}\" start=\"${start}\" duration=\"${dur}\"${laneAttr}/>`
          );
        });

        const xml = [
          '<?xml version="1.0" encoding="UTF-8"?>',
          '<fcpxml version="1.9">',
          '  <resources>',
          `    <format id=\"${formatId}\" name=\"CamOrderFormat\" frameDuration=\"${frameDuration}\" width=\"${formatWidth}\" height=\"${formatHeight}\"/>`,
          assetLines.join('\n'),
          '  </resources>',
          '  <library>',
          '    <event name="CamOrder">',
          '      <project name="CamOrder">',
          `        <sequence format=\"${formatId}\" duration=\"${totalDuration}\" tcStart=\"0s\" tcFormat=\"NDF\">`,
          '          <spine>',
          spineLines.join('\n'),
          '          </spine>',
          '        </sequence>',
          '      </project>',
          '    </event>',
          '  </library>',
          '</fcpxml>',
        ].filter((line) => line !== '').join('\n');

        Array.from(usedClipIds).forEach((clipId) => {
          const clip = getClipById(clipId);
          if (clip && clip.__assetId) delete clip.__assetId;
        });

        return xml;
      }

      function buildFlatFcpXml(preferMp4 = true) {
        const fps = state.settings.fps;
        const segments = buildFlatSegments();
        const usedClipIds = new Set();
        segments.forEach((segment) => {
          const placement = getPlacementById(segment.placementId);
          if (placement) usedClipIds.add(placement.clipId);
        });

        const formatId = 'r1';
        const formatWidth = 1920;
        const formatHeight = 1080;
        const frameDuration = `1/${fps}s`;
        const totalDuration = secondsToFcpDuration(getTimelineDurationSeconds(), fps);

        const assetLines = [];
        Array.from(usedClipIds).forEach((clipId, index) => {
          const clip = getClipById(clipId);
          if (!clip) return;
          const assetId = `r${index + 2}`;
          const filename = resolveClipFilename(clip, preferMp4);
          const src = makeFileUrl(state.export.mediaBasePath, filename);
          const duration = secondsToFcpDuration(Math.max(clip.durationSeconds, 0), fps);
          const safeName = (clip.name || clip.id).replace(/\"/g, '');
          assetLines.push(
            `    <asset id=\"${assetId}\" name=\"${safeName}\" src=\"${src}\" start=\"0s\" duration=\"${duration}\" hasVideo=\"1\" hasAudio=\"0\" format=\"${formatId}\"/>`
          );
          clip.__assetId = assetId;
        });

        const spineLines = [];
        segments.forEach((segment) => {
          const placement = getPlacementById(segment.placementId);
          if (!placement) return;
          const clip = getClipById(placement.clipId);
          if (!clip) return;
          const assetId = clip.__assetId;
          const clipName = (clip.name || clip.id).replace(/\"/g, '');
          const segStart = snapSeconds(segment.start, fps);
          const segEnd = snapSeconds(segment.end, fps);
          const clipIn = snapSeconds(placement.clipInSeconds + (segStart - placement.timelineStartSeconds), fps);
          const clipOut = snapSeconds(clipIn + (segEnd - segStart), fps);
          const offset = secondsToFcpDuration(segStart, fps);
          const start = secondsToFcpDuration(clipIn, fps);
          const duration = secondsToFcpDuration(clipOut - clipIn, fps);
          spineLines.push(
            `          <asset-clip name=\"${clipName}\" ref=\"${assetId}\" offset=\"${offset}\" start=\"${start}\" duration=\"${duration}\"/>`
          );
        });

        const xml = [
          '<?xml version="1.0" encoding="UTF-8"?>',
          '<fcpxml version="1.9">',
          '  <resources>',
          `    <format id=\"${formatId}\" name=\"CamOrderFormat\" frameDuration=\"${frameDuration}\" width=\"${formatWidth}\" height=\"${formatHeight}\"/>`,
          assetLines.join('\n'),
          '  </resources>',
          '  <library>',
          '    <event name="CamOrder">',
          '      <project name="CamOrder">',
          `        <sequence format=\"${formatId}\" duration=\"${totalDuration}\" tcStart=\"0s\" tcFormat=\"NDF\">`,
          '          <spine>',
          spineLines.join('\n'),
          '          </spine>',
          '        </sequence>',
          '      </project>',
          '    </event>',
          '  </library>',
          '</fcpxml>',
        ].filter((line) => line !== '').join('\n');

        Array.from(usedClipIds).forEach((clipId) => {
          const clip = getClipById(clipId);
          if (clip && clip.__assetId) delete clip.__assetId;
        });

        return xml;
      }

      function buildFlatSegments() {
        const placements = getPlacementsForExport();
        const boundaries = new Set();
        placements.forEach((placement) => {
          boundaries.add(placement.timelineStartSeconds);
          boundaries.add(placement.end);
        });
        const times = Array.from(boundaries).sort((a, b) => a - b);
        const segments = [];

        for (let i = 0; i < times.length - 1; i += 1) {
          const start = times[i];
          const end = times[i + 1];
          if (end <= start) continue;
          const mid = (start + end) / 2;
          const active = placements.filter((placement) => mid >= placement.timelineStartSeconds && mid < placement.end);
          if (!active.length) continue;
          active.sort((a, b) => a.timelineStartSeconds - b.timelineStartSeconds);
          const top = active[active.length - 1];
          const last = segments[segments.length - 1];
          if (last && last.placementId === top.id) {
            last.end = end;
          } else {
            segments.push({ placementId: top.id, start, end });
          }
        }

        return segments;
      }

      function buildFlatEdl(preferMp4 = true) {
        const fps = state.settings.fps;
        const segments = buildFlatSegments();
        const lines = [];
        lines.push('TITLE: CamOrder Flattened');
        lines.push('FCM: NON-DROP FRAME');

        segments.forEach((segment, index) => {
          const placement = getPlacementById(segment.placementId);
          if (!placement) return;
          const clip = getClipById(placement.clipId);
          const filename = resolveClipFilename(clip, preferMp4);
          const reel = sanitizeReelName(filename);
          const segStart = snapSeconds(segment.start, fps);
          const segEnd = snapSeconds(segment.end, fps);
          const clipIn = snapSeconds(placement.clipInSeconds + (segStart - placement.timelineStartSeconds), fps);
          const clipOut = snapSeconds(clipIn + (segEnd - segStart), fps);
          const recIn = secondsToSMPTE(segStart, fps);
          const recOut = secondsToSMPTE(segEnd, fps);
          const srcIn = secondsToSMPTE(clipIn, fps);
          const srcOut = secondsToSMPTE(clipOut, fps);
          const eventNum = pad(index + 1, 3);
          lines.push(`${eventNum}  ${reel.padEnd(8)} V     C        ${srcIn} ${srcOut} ${recIn} ${recOut}`);
          lines.push(`* FROM CLIP NAME: ${filename}`);
        });

        if (!segments.length) {
          lines.push('* (No placements to export)');
        }

        return lines.join('\n');
      }

      function buildFfmpegScriptSh() {
        return [
          '#!/bin/sh',
          'set -e',
          'mkdir -p media',
          'for f in media/*.webm; do',
          '  [ -e "$f" ] || continue',
          '  base=$(basename "$f" .webm)',
          '  ffmpeg -y -i "$f" -c:v prores_ks -profile:v 3 -pix_fmt yuv422p10le -an "media/${base}.mov"',
          '  rm -f "$f"',
          'done',
        ].join('\n');
      }

      async function writeProjectFile(filename, content, contentType = 'text/plain') {
        if (!state.projectHandle) return false;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return false;
        const handle = await state.projectHandle.getFileHandle(filename, { create: true });
        const writable = await handle.createWritable();
        await writable.write(new Blob([content], { type: contentType }));
        await writable.close();
        return true;
      }

      async function writeMediaFile(filename, content, contentType = 'text/plain') {
        if (!state.projectHandle) return false;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return false;
        const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: true });
        const handle = await mediaDir.getFileHandle(filename, { create: true });
        const writable = await handle.createWritable();
        await writable.write(new Blob([content], { type: contentType }));
        await writable.close();
        return true;
      }

      async function removeExportArtifacts() {
        if (!state.projectHandle || !state.projectHandle.removeEntry) return;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return;
        const files = [
          'camorder-stacked-mov.fcpxml',
          'convert-to-mov.sh',
        ];
        for (const filename of files) {
          try {
            await state.projectHandle.removeEntry(filename);
          } catch (error) {
            if (error && error.name !== 'NotFoundError') {
              console.warn('Failed to remove export file', filename, error);
            }
          }
        }
        try {
          const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: false });
          await mediaDir.removeEntry('camorder-stacked-mov.fcpxml');
        } catch (error) {
          if (error && error.name !== 'NotFoundError') {
            console.warn('Failed to remove media export file', error);
          }
        }
      }

      async function exportResolvePackage() {
        if (window.showDirectoryPicker && !state.projectHandle) {
          await chooseProjectFolder();
        }
        if (!state.projectHandle && window.showDirectoryPicker) {
          setExportStatus('Export canceled. Choose a project folder first.');
          updateFolderStatus();
          return;
        }
        if (state.projectHandle) {
          await removeExportArtifacts();
        }
        const fcpxmlMov = buildStackedFcpXml(true);
        const xmlMovName = 'camorder-stacked-mov.fcpxml';

        if (state.projectHandle) {
          await writeMediaFile(xmlMovName, fcpxmlMov, 'application/xml');
          await writeProjectFile('convert-to-mov.sh', buildFfmpegScriptSh(), 'text/x-shellscript');
        } else {
          downloadBlob(new Blob([fcpxmlMov], { type: 'application/xml' }), xmlMovName);
          downloadBlob(new Blob([buildFfmpegScriptSh()], { type: 'text/x-shellscript' }), 'convert-to-mov.sh');
        }
        const hint = getConvertCommand();
        if (hint) {
          const copied = await copyTextToClipboard(hint);
          setExportStatus(
            copied
              ? 'Resolve package exported. Convert command copied to clipboard.'
              : 'Resolve package exported. Use the Copy button in the Project panel.'
          );
        } else {
          setExportStatus('Resolve package exported. Convert command unavailable for this folder selection.');
        }
      }

      function getClipById(clipId) {
        return state.clips.find((clip) => clip.id === clipId);
      }

      function getPlacementById(placementId) {
        return state.placements.find((placement) => placement.id === placementId);
      }

      function getTimelineDurationSeconds() {
        let maxEnd = 0;
        for (const placement of state.placements) {
          const end = placement.timelineStartSeconds + placement.durationSeconds;
          if (end > maxEnd) maxEnd = end;
        }
        return Math.max(0, maxEnd);
      }

      async function startRecording() {
        if (state.recording.active || state.recording.pending) return;
        if (!state.projectHandle) {
          setExportStatus('Choose a project folder before recording.');
          updateFolderStatus();
          return;
        }
        if (!state.armed) return;

        state.recording.pending = true;
        const stream = await getCameraStream();
        if (!stream) {
          state.recording.pending = false;
          return;
        }

        const mimeType = getSupportedMimeType();
        const extension = 'webm';
        const clipId = makeId('clip');
        const clipName = `Take ${pad(state.clips.length + 1, 3)} ${secondsToSMPTE(state.playheadSeconds, state.settings.fps)}`;
        const clip = {
          id: clipId,
          name: clipName,
          createdAt: new Date().toISOString(),
          durationSeconds: 0,
          source: 'recorded',
          filename: `${clipId}.${extension}`,
          startSeconds: state.playheadSeconds,
        };
        state.clips.push(clip);

        const placement = {
          id: makeId('plc'),
          clipId,
          timelineStartSeconds: state.playheadSeconds,
          clipInSeconds: 0,
          clipOutSeconds: 0,
          durationSeconds: 0,
          lane: state.timeline.selectedLane || 0,
        };
        state.placements.push(placement);

        const recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
        const chunks = [];
        recorder.ondataavailable = (event) => {
          if (event.data.size > 0) chunks.push(event.data);
        };
        recorder.onstop = () => {
          finalizeRecording({ clipId, chunks, mimeType, placementId: placement.id, stream });
        };
        recorder.start(200);

        state.recording = {
          active: true,
          pending: false,
          clipId,
          startPlayhead: state.playheadSeconds,
          recorder,
          chunks,
        };
        setRecordStatus('recording');
        setCameraStatus('live');
      }

      function updateRecordingDuration() {
        if (!state.recording.active) return;
        const duration = Math.max(0, state.playheadSeconds - state.recording.startPlayhead);
        const placement = state.placements.find((item) => item.clipId === state.recording.clipId);
        if (placement) {
          placement.durationSeconds = duration;
          placement.clipOutSeconds = placement.clipInSeconds + duration;
        }
        updateTimelineRecordingClip();
        renderStageView();
      }

      function generateThumbnail(clip, blob) {
        return new Promise((resolve) => {
          const url = URL.createObjectURL(blob);
          const video = document.createElement('video');
          video.preload = 'metadata';
          video.muted = true;
          video.src = url;

          const cleanup = () => {
            URL.revokeObjectURL(url);
          };

          video.addEventListener('loadedmetadata', () => {
            const target = Number.isFinite(video.duration) && video.duration > 0 ? Math.min(0.1, video.duration / 2) : 0;
            try {
              video.currentTime = target;
            } catch (error) {
              cleanup();
              resolve('');
            }
          }, { once: true });

          video.addEventListener('seeked', () => {
            const canvas = document.createElement('canvas');
            const width = video.videoWidth || 160;
            const height = video.videoHeight || 90;
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (ctx) ctx.drawImage(video, 0, 0, width, height);
            cleanup();
            resolve(canvas.toDataURL('image/jpeg', 0.7));
          }, { once: true });

          video.addEventListener('error', () => {
            cleanup();
            resolve('');
          }, { once: true });
        });
      }

      function finalizeRecording(recording) {
        const clip = getClipById(recording.clipId);
        if (!clip) return;
        const blob = new Blob(recording.chunks, { type: recording.mimeType || 'video/webm' });
        clip.durationSeconds = Math.max(0, state.playheadSeconds - clip.startSeconds);
        const placement = state.placements.find((item) => item.clipId === clip.id);
        if (placement) {
          placement.durationSeconds = clip.durationSeconds;
          placement.clipOutSeconds = placement.clipInSeconds + clip.durationSeconds;
        }
        const url = URL.createObjectURL(blob);
        state.mediaCache.set(clip.id, { blob, url, filename: clip.filename });
        if (state.projectHandle) {
          saveRecordedClipToProject(clip, blob).catch((error) => {
            console.warn('Failed to save clip to project folder', error);
          });
        }
        if (!state.camera.stream || recording.stream !== state.camera.stream) {
          recording.stream.getTracks().forEach((track) => track.stop());
        }
        state.recording = { active: false, pending: false, clipId: null, startPlayhead: 0, recorder: null, chunks: [] };
        setRecordStatus(state.armed ? 'armed' : 'idle');
        setCameraStatus(state.camera.stream && state.camera.stream.active ? 'ready' : 'off');
        markDirty();
        renderTakes();
        renderTimeline();
        generateThumbnail(clip, blob).then((thumb) => {
          if (!thumb) return;
          clip.thumbnail = thumb;
          renderTakes();
        });
        renderStageView();
      }

      function stopRecording() {
        if (!state.recording.active) return;
        const { recorder } = state.recording;
        if (recorder && recorder.state !== 'inactive') {
          recorder.stop();
        }
      }

      function renderTakes() {
        dom.takesList.innerHTML = '';
        if (!state.clips.length) {
          const empty = document.createElement('div');
          empty.className = 'take-meta';
          empty.textContent = 'No takes recorded yet.';
          dom.takesList.appendChild(empty);
          return;
        }
        const fragment = document.createDocumentFragment();
        state.clips.forEach((clip) => {
          const placement = state.placements.find((item) => item.clipId === clip.id);
          const item = document.createElement('div');
          item.className = 'take-item';
          const thumb = document.createElement('div');
          thumb.className = 'take-thumb';
          if (clip.thumbnail) {
            thumb.style.backgroundImage = `url(${clip.thumbnail})`;
          }
          const info = document.createElement('div');
          info.className = 'take-info';
          const title = document.createElement('div');
          title.className = 'take-title';
          title.textContent = clip.name;
          const meta = document.createElement('div');
          meta.className = 'take-meta';
          const startTc = secondsToSMPTE(clip.startSeconds || 0, state.settings.fps);
          const dur = placement ? placement.durationSeconds : clip.durationSeconds;
          meta.textContent = `Start ${startTc} | ${dur.toFixed(2)}s | ${clip.filename}`;
          const actions = document.createElement('div');
          actions.className = 'take-actions';
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'ghost take-delete';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            deleteClipAndPlacements(clip.id);
          });
          actions.appendChild(deleteBtn);
          info.appendChild(title);
          info.appendChild(meta);
          info.appendChild(actions);
          item.appendChild(thumb);
          item.appendChild(info);
          fragment.appendChild(item);
        });
        dom.takesList.appendChild(fragment);
      }

      function deleteClipAndPlacements(clipId) {
        const clipIndex = state.clips.findIndex((clip) => clip.id === clipId);
        if (clipIndex === -1) return;
        state.clips.splice(clipIndex, 1);
        state.placements = state.placements.filter((placement) => placement.clipId !== clipId);
        if (state.timeline.selectionId) {
          const stillExists = state.placements.some((placement) => placement.id === state.timeline.selectionId);
          if (!stillExists) state.timeline.selectionId = null;
        }
        const cached = state.mediaCache.get(clipId);
        if (cached && cached.url) URL.revokeObjectURL(cached.url);
        state.mediaCache.delete(clipId);
        markDirty();
        renderTakes();
        renderTimeline();
        renderStageView();
      }

      function pickPreferredMidiInput(inputs) {
        if (!inputs.length) return '';
        const priority = [/logic/i, /iac/i, /virtual/i, /bus/i];
        for (const pattern of priority) {
          const match = inputs.find((input) => pattern.test(input.name || ''));
          if (match) return match.id;
        }
        return inputs[0].id;
      }

      function refreshMidiInputs() {
        if (!state.midi.access) return;
        const inputs = Array.from(state.midi.access.inputs.values());
        const currentSelection = dom.midiInputSelect.value;
        dom.midiInputSelect.innerHTML = '';
        if (!inputs.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No MIDI inputs';
          dom.midiInputSelect.appendChild(opt);
          return;
        }
        inputs.forEach((input) => {
          const opt = document.createElement('option');
          opt.value = input.id;
          opt.textContent = input.name || input.id;
          dom.midiInputSelect.appendChild(opt);
        });
        if (currentSelection && inputs.some((input) => input.id === currentSelection)) {
          dom.midiInputSelect.value = currentSelection;
        } else {
          dom.midiInputSelect.value = pickPreferredMidiInput(inputs);
        }
      }

      async function requestMidiAccess() {
        if (!navigator.requestMIDIAccess) {
          setMidiStatus('warn', 'MIDI Unsupported');
          return null;
        }
        try {
          const access = await navigator.requestMIDIAccess();
          return access;
        } catch (error) {
          console.warn('MIDI access error', error);
          setMidiStatus('warn', 'MIDI Blocked');
          return null;
        }
      }

      function disconnectMidi() {
        if (state.midi.input) {
          state.midi.input.onmidimessage = null;
        }
        state.midi.input = null;
        state.midi.connected = false;
        state.midi.clock.playing = false;
        dom.midiConnectBtn.textContent = 'Enable MIDI';
        setMidiStatus('ready', 'MIDI Ready');
        setRecordStatus(state.armed ? 'armed' : 'idle');
      }

      async function connectMidi() {
        if (state.midi.connected) {
          disconnectMidi();
          return;
        }
        if (!state.midi.access) {
          state.midi.access = await requestMidiAccess();
          if (!state.midi.access) return;
          state.midi.access.onstatechange = refreshMidiInputs;
        }
        refreshMidiInputs();
        const inputId = dom.midiInputSelect.value;
        const input = Array.from(state.midi.access.inputs.values()).find((item) => item.id === inputId);
        if (!input) {
          setMidiStatus('warn', 'No MIDI Input');
          return;
        }
        state.midi.input = input;
        state.midi.input.onmidimessage = handleMidiMessage;
        state.midi.connected = true;
        state.midi.clock.lastTick = 0;
        state.midi.clock.playing = false;
        dom.midiConnectBtn.textContent = 'Disable MIDI';
        setMidiStatus('connected', input.name || 'MIDI Connected');
        setRecordStatus(state.armed ? 'armed' : 'idle');
      }

      function handleSongPositionPointer(lsb, msb) {
        const spp = (msb << 7) | lsb;
        const bpm = Math.max(20, state.midi.clock.bpm || 120);
        const seconds = (spp * 60) / (bpm * 4);
        state.midi.clock.songPositionSeconds = seconds;
        setPlayhead(seconds);
      }

      function handleMidiClockTick(timeStamp) {
        const lastTick = state.midi.clock.lastTick;
        if (lastTick) {
          const delta = Math.max(0.001, (timeStamp - lastTick) / 1000);
          const bpm = 60 / (delta * 24);
          if (Number.isFinite(bpm) && bpm >= 20 && bpm <= 300) {
            state.midi.clock.bpm = state.midi.clock.bpm * 0.85 + bpm * 0.15;
            updateBpmDisplay();
          }
        }
        state.midi.clock.lastTick = timeStamp;
        if (!state.midi.clock.playing) return;
        const tickSeconds = 60 / (state.midi.clock.bpm * 24);
        setPlayhead(state.playheadSeconds + tickSeconds);
        updateRecordingDuration();
        if (canAutoRecord()) {
          if (!state.recording.active && !state.recording.pending) {
            startRecording();
          }
        }
      }

      function handleMidiMessage(event) {
        const data = event.data;
        const status = data[0];
        if (status === 0xF8) {
          handleMidiClockTick(event.timeStamp);
          return;
        }
        if (status === 0xFA) {
          state.midi.clock.playing = true;
          setPlayhead(state.midi.clock.songPositionSeconds || 0);
          return;
        }
        if (status === 0xFB) {
          state.midi.clock.playing = true;
          return;
        }
        if (status === 0xFC) {
          state.midi.clock.playing = false;
          if (state.recording.active) stopRecording();
          return;
        }
        if (status === 0xF2 && data.length > 2) {
          handleSongPositionPointer(data[1], data[2]);
        }
      }

      function updateArmedUi() {
        dom.armBtn.textContent = state.armed ? 'Armed' : 'Arm Recorder';
        dom.armBtn.classList.toggle('danger', state.armed);
        setRecordStatus(state.recording.active ? 'recording' : (state.armed ? 'armed' : 'idle'));
      }

      function canAutoRecord() {
        return Boolean(
          state.armed &&
          state.projectHandle &&
          state.camera.stream &&
          state.camera.stream.active
        );
      }

      function updateFps() {
        state.settings.fps = parseInt(dom.fpsSelect.value, 10);
        setPlayhead(state.playheadSeconds);
        renderTakes();
        renderTimeline();
      }

      function setupEvents() {
        dom.midiConnectBtn.addEventListener('click', connectMidi);
        dom.midiInputSelect.addEventListener('change', () => {
          if (state.midi.connected) {
            disconnectMidi();
            connectMidi();
          }
        });
        dom.armBtn.addEventListener('click', () => {
          state.armed = !state.armed;
          updateArmedUi();
        });
        dom.fpsSelect.addEventListener('change', updateFps);
        dom.enableCameraBtn.addEventListener('click', () => warmUpCamera(true));
        dom.refreshDevices.addEventListener('click', refreshDevices);
        dom.cameraSelect.addEventListener('change', () => {
          clearCameraStream(true);
          setCameraStatus('off');
          updateCameraSourceUI();
        });
        dom.resolutionSelect.addEventListener('change', () => {
          clearCameraStream(true);
          setCameraStatus('off');
        });
        dom.chooseFolderBtn.addEventListener('click', chooseProjectFolder);
        dom.exportPackageBtn.addEventListener('click', exportResolvePackage);
        if (dom.copyConvertBtn) {
          dom.copyConvertBtn.addEventListener('click', async () => {
            const value = getConvertCommand();
            const copied = await copyTextToClipboard(value);
            if (copied) setExportStatus('Convert command copied to clipboard.');
          });
        }
        if (dom.toggleTimelineBtn) {
        dom.toggleTimelineBtn.addEventListener('click', () => {
          state.timeline.enabled = !state.timeline.enabled;
          document.getElementById('app').classList.toggle('timeline-enabled', state.timeline.enabled);
          dom.toggleTimelineBtn.textContent = state.timeline.enabled
            ? 'Hide Experimental Timeline'
            : 'Experimental Video Timeline';
          state.timeline.lastGridBpm = getBpm();
          if (dom.takesHeader) {
            dom.takesHeader.textContent = state.timeline.enabled ? 'Stage' : 'Takes';
          }
          moveProjectBlock();
          renderTimeline();
          updateTimelinePlayhead();
          renderStageView();
        });
      }
        if (dom.laneSelect) {
          dom.laneSelect.addEventListener('change', () => {
            state.timeline.selectedLane = parseInt(dom.laneSelect.value, 10) || 0;
          });
        }
        if (dom.addLaneBtn) {
          dom.addLaneBtn.addEventListener('click', () => {
            state.timeline.lanes += 1;
            updateLaneSelect();
            renderTimeline();
          });
        }
        if (dom.deletePlacementBtn) {
          dom.deletePlacementBtn.addEventListener('click', deleteSelectedPlacement);
        }
        if (dom.timelineViewport) {
          dom.timelineViewport.addEventListener('mousedown', handleTimelineMouseDown);
        }
        window.addEventListener('mousemove', handleTimelineMouseMove);
        window.addEventListener('mouseup', handleTimelineMouseUp);
        window.addEventListener('keydown', (event) => {
          if (!state.timeline.enabled) return;
          if (event.target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) return;
          if (event.key === 'Delete' || event.key === 'Backspace') {
            deleteSelectedPlacement();
          }
        });
        dom.liveVideo.addEventListener('loadedmetadata', () => {
          dom.liveVideo.play().catch(() => {});
        });

        window.addEventListener('beforeunload', (event) => {
          if (!state.dirty) return;
          event.preventDefault();
          event.returnValue = '';
        });
      }

      function init() {
        cacheDom();
        setupEvents();
        populateResolutionOptions();
        refreshDevices();
        setCameraStatus('off');
        updateExportNotes();
        updateFolderStatus();
        updateBpmDisplay();
        updateArmedUi();
        renderTakes();
        updateLaneSelect();
        document.getElementById('app').classList.toggle('timeline-enabled', state.timeline.enabled);
        if (dom.toggleTimelineBtn) {
          dom.toggleTimelineBtn.textContent = state.timeline.enabled
            ? 'Hide Experimental Timeline'
            : 'Experimental Video Timeline';
        }
        if (dom.takesHeader) {
          dom.takesHeader.textContent = state.timeline.enabled ? 'Stage' : 'Takes';
        }
        moveProjectBlock();
        if (navigator.requestMIDIAccess) {
          setMidiStatus('ready', 'MIDI Ready');
          requestMidiAccess().then((access) => {
            if (!access) return;
            state.midi.access = access;
            state.midi.access.onstatechange = refreshMidiInputs;
            refreshMidiInputs();
          });
        } else {
          setMidiStatus('warn', 'MIDI Unsupported');
          dom.midiConnectBtn.disabled = true;
          dom.midiInputSelect.disabled = true;
        }
      }

      window.addEventListener('load', init);
    })();
  </script>
</body>
</html>
